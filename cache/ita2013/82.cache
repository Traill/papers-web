{"id":"82","paper":{"title":{"text":"Learning Sparse Priors in Approximate Message Passing "},"authors":[{"name":"Alyson Fletcher"},{"name":"Ulugbek Kamilov"},{"name":"Sundeep Rangan"},{"name":"Michael Unser"}],"abstr":{"text":"We consider the estimation of an i.i.d. (possibly non-Gaussian) vector from measurements obtained by a cascade model of a linear transform followed by a probabilistic componentwise (possibly nonlinear) measurement channel. A novel method, called adaptive generalized approximate message passing (adaptive GAMP) is presented that enables the joint learning of the statistics of the prior and measurement channel along with estimation of the unknown vector. It is shown that, for large i.i.d. Gaussian transform matrices, the asymptotic component-wise behavior of adaptive GAMP is predicted by a simple set of scalar state evolution equations and that the parameter estimates are provably asymptotically consistent under essentially arbitrary parametrizations."},"body":{"text":"The recent work of Feldman, Wainwright and Karger [4] shows that maximum likelihood (ML) decoding of a binary linear code C over a discrete memoryless channel can be formulated as a linear programming problem. Recall that the ML decoding problem is: given a received word y at the channel output, ﬁnd a codeword x ∈ C that maximizes the probability, Pr[y|x], of receiving y conditioned on the event that x was transmitted. As observed by Feldman et al., under the assumption of a discrete memoryless channel, given a received word y = y 1 y 2 . . . y n , the problem of determining arg max x ∈C Pr[y|x] is equivalent to the problem of ﬁnding arg min x ∈C γ, x , where γ = (γ 1 , γ 2 , . . . , γ n ) is given by\nx = x 1 x 2 . . . x n ∈ C is identiﬁed with the real vector (x 1 , x 2 , . . . , x n ) ∈ {0, 1} n ⊂ R n .\nThe above formulation shows ML decoding to be equivalent to the minimization of a linear function over a ﬁnite set C ⊂ {0, 1} n . Let P (C) be the code polytope of C, i.e., the convex hull in R n of the ﬁnite set C. It can be shown that the set of vertices of P (C) coincides with C. The key point\nnow is that over a polytope P , a linear function φ attains its minimum value φ min = min{φ(x) : x ∈ P } at a vertex of P . In particular, arg min x ∈P (C) γ, x = arg min x ∈C γ, x . Thus, ML decoding is in fact equivalent to the minimization of a linear function over a polytope. This, as noted in [4], is a classic linear program (LP) since a polytope can always be represented as a polyhedron, which by deﬁnition, is the solution set to a ﬁnite system of linear inequalities.\nAn LP is simply the minimization of a linear cost function over a polyhedron. The degree of difﬁculty involved in solving an LP is directly related to the number of variables in the problem and the number of inequalities deﬁning the polyhe- dron. Since it is possible for two distinct systems of linear inequalities to have the same solution set, a given polyhedron may in general have many different representations in terms of linear inequalities. Thus, with a view towards reducing the complexity of an LP over a given polyhedron, it is clearly important to ﬁnd a minimal representation of the polyhedron that involves the least number of inequalities among all its representations via linear inequalities. In particular, an efﬁcient implementation of the ML decoding problem for a code C as an LP would require a minimal polyhedral representation of the code polytope P (C). The work of Barahona and Gr¨otschel [1] is the obvious starting point in any study of code polytopes. The results in that work are couched in the language of binary matroids, and translations of those results into the language of coding theory can be found scattered throughout our paper. Section III of our paper describes one of the main theorems of [1], which gives a minimal polyhedral representation of P (C) for nearly any code C, and also precisely characterizes the exceptional codes not covered by this representation.\nHowever, ML decoding of an arbitrary code is known to be NP-hard. So, in general, no polyhedral representation of the code polytope can make linear programming over the polytope an attractive, or even feasible, option. A strategy often followed in such a situation is to \u201crelax\u201d the problem. The idea is to look for a polytope that contains the code as a subset of its vertex set, but has a more manageable polyhedral representation; the cost function is then minimized over this \u201crelaxed\u201d polytope.\nA simple way of relaxing a code polytope P (C) is to cast out some subset of the inequalities forming a polyhedral representation of P (C), while restricting the resulting polytope to remain within the n-cube [0, 1] n . This relaxation procedure\nensures that the codewords in C continue to be vertices of the relaxed polytope. The \u201cprojected polytope\u201d Q of Feldman et al. [4, p. 958] and the equivalent \u201cfundamental polytope\u201d of Vontobel and Koetter [9], [11], as well as the \u201crth relaxation\u201d polytope deﬁned in [11, Deﬁnition 11], are examples of such relaxations of the code polytope. Now, the polytopes so obtained generally have more vertices than the original code polytope. These additional vertices are also potential minimiz- ers of the cost function γ, x over the relaxed polytope, but as they are not codewords, they are spurious solutions to the decoding algorithm and represent decoding failure. This was noted in [4], where the term \u201cpseudocodeword\u201d is used 1 to denote a vertex (or more accurately, a vertex scaled so as to lie in the integer lattice Z n ) of the polytope Q.\nThus, relaxing the code polytope to reduce the complexity of the LP creates extra vertices that causes the LP over the relaxed polytope to perform worse as a decoding algorithm than ML decoding. There is thus a trade-off between complexity of the LP and its performance as a decoding algorithm, which is poorly understood at present. It is our thesis that in order to understand this trade-off, it is important to gain a thorough understanding of the structure of a code polytope. This should help in ﬁnding sharp estimates of the number of extra vertices in relaxations of the polytope, and may also help in ﬁnding relaxations that introduce relatively few extra vertices. One of the aims of this paper is to initiate a study of the complete facial structure of a code polytope, and we present some preliminary results in Section IV.\nIt turns out that the geometry of code polytopes implies a simple lower bound on the number of minimal codewords in a code. In Section V, we present this bound along with a necessary and sufﬁcient condition for the bound to be met with equality. This derivation yields an interesting intermediate result that characterizates code polytopes that are simple, i.e., polytopes in which each vertex is incident with exactly n edges, n being the dimension of the polytope.\nWe establish in this section the language used to present our results in later sections. We follow for the most part the standard terminology of coding theory [10] and discrete convex geometry [2]. As the average reader is expected to be familiar with the former, we elaborate on the latter.\nGiven a binary linear code C, we let d(C) denote its minimum distance. We deﬁne the support of a codeword c = c 1 c 2 . . . c n ∈ C to be supp(c) = {i : c i = 1} , and also deﬁne supp(C) = c ∈C supp(c) to be the support of C. A codeword c ∈ C, c = 0, is called minimal if its support supp(c) does not contain as a subset the support of any other nonzero codeword in C. The set of all minimal codewords of C is denoted by M(C).\nThe dual code of C will be denoted by C ⊥ . A code D is said to be a minor of C if D can be obtained from C by a series of puncturing and shortening operations. A polytope in R\nn is the convex hull of a ﬁnite set of points in R n . In this paper, we will be interested in polytopes associated with binary linear codes. Let C be an [n, k] binary linear code. Each codeword c 1 c 2 . . . c n ∈ C , c i ∈ {0, 1} , can be identiﬁed with the point (c 1 , c 2 , . . . , c n ) ∈ R n . Thus, C is identiﬁed with a set of 2 k points in {0, 1} n ⊂ R n , which we will continue to denote by C. The code polytope of C is deﬁned to be the convex hull of C in R\nn , and will be denoted by P (C). A code polytope is thus a 0/1-polytope in that it is the convex hull of some subset of {0, 1} n (cf. [14]).\nThe dimension of a polytope P ⊂ R n , denoted by dim(P ), is deﬁned to be the dimension of its afﬁne hull (which is the smallest afﬁne subspace in R n containing P ). Thus, dim(P ) ≤ n , with strict inequality being possible. The following result explicitly determines dim(P (C)) for a binary linear code C.\nTheorem 2.1 ([1], Theorem 4.1): Given a binary linear code C, let K be a largest subset of supp(C) with the property that for all i, j ∈ K, i = j, there exists c 1 c 2 . . . c n ∈ C with c i = c j . Then, dim(P (C)) = |K|.\nA polytope P ⊂ R n with dim(P ) = n is said to be full- dimensional. The following corollary to the above theorem succinctly characterizes full-dimensional code polytopes.\nCorollary 2.2: For any binary linear code C of length n, dim(P (C)) = n iff d(C ⊥ ) / ∈ {1, 2} .\nFor the most part, in this paper, we will consider full- dimensional code polytopes only, as codes C with d(C ⊥ ) ∈ {1, 2} are not very interesting, and can always be punctured to obtain a code whose polytope is full-dimensional.\nLet · denote the standard inner product in R n . Given a ∈ R n and β ∈ R, the set H = {x ∈ R n : a , x = β} is called a(n afﬁne) hyperplane, and the set H\n≤ = {x ∈ R n : a, x ≤ β} is called a closed halfspace. Given a polytope P ⊂ R n , a (possibly empty) subset F ⊂ P is called a face of P if there exists a hyperplane H ⊂ R n such that P is contained in the closed halfspace H\n≤ , and F = P ∩ H. A face of a polytope is itself a polytope. A 0-dimensional face of a polytope P is called a vertex, a 1-dimensional face is called an edge, and a face of dimension dim(P ) − 1 is called a facet. The only face of dimension dim(P ) is P itself. In general, a k-dimensional face is referred to as a k-face. The two basic n-dimensional 0/1-polytopes that we will often encounter are the n-cube, [0, 1] n , which we denote by n , and the n-simplex ∆ n , which is the convex hull of {0, e 1 , . . . , e n } ⊂ R n , where e 1 , . . . , e n is the standard basis of R n . Thus, for example, ∆ 1 is a line segment, ∆ 2 a triangle, and ∆\na tetrahedron. We will need the notion of afﬁne equivalence of polytopes: two polytopes P ⊂ R m and Q ⊂ R n are afﬁnely equivalent if there exists an afﬁne map f : R\nm → R n that is a bijection between P and Q. Any n-dimensional polytope with n + 1 vertices is afﬁnely equivalent to the n-simplex ∆ n , and so is also usually referred to as a simplex.\nA polyhedron is the intersection of ﬁnitely many closed halfspaces in R n . By the Weyl-Minkowski Theorem [2, p. 9], a set P ⊂ R\nn is a polytope iff it is a bounded polyhedron. Thus, a polytope has a dual representation as a polyhedron. However, a polytope does not in general have a unique polyhedral representation, i.e., it could be represented as an intersection of closed halfspaces in a variety of ways. But, there is a unique minimal polyhedral representation of a polytope P which requires the minimum number of halfspaces (or equivalently, linear inequalities) among all polyhedral representations of P . An inequality a, x ≤ β is called facet-deﬁning for P if\na , x ≤ β holds for all x ∈ P , and {x ∈ P : a, x = β} is a facet of P . For a full-dimensional polytope P , the minimal polyhedral representation consists of precisely the facet-deﬁning inequalities for P .\nIt is a somewhat surprising fact that the minimal polyhedral representation can be explicitly given for most code polytopes, and we quickly summarize this result in this section. For simplicity, we state the result only in the case when d(C ⊥ ) / ∈ {1, 2} , so that P (C) is a full-dimensional code polytope. The most general statements can be found in [1], and are given there in the language of matroid theory.\nThe result given below is valid for a class of codes with a certain set of excluded minors. To be precise, it holds for binary linear codes C with the property that C does not have as a minor any code equivalent to one of the following:\n2) the [10, 5, 4] code, denoted by R 10 , the columns of whose parity check matrix are the ten words of length 5 and Hamming weight 3;\n3) the [10, 4, 4] code, denoted by M ∗ (K 5 ) , the columns of whose generator matrix consists are the ten nonzero words of length 4 and Hamming weight at most 2.\nWe need one last piece of notation to state the theorem on polyhedral representations. Recall that M(C) denotes the set of minimal codewords of C. The boundary, ∂M(C), of M(C) is deﬁned to be the set of all c ∈ M(C) such that c = p ⊕ q for some p, q ∈ M(C) with |supp(p) ∩ supp(q)| = 1. Here and hereafter, ⊕ denotes modulo-2 addition. Let M(C) ◦ = M(C) \\ ∂M(C) . We are now in a position to state the rather elaborate result on minimal polyhedral representations of code polytopes.\nTheorem 3.1 ([1], Theorem 4.22): Let C be a binary linear code of length n, with d(C ⊥ ) / ∈ {1, 2} , and let I denote the union of the supports of weight-3 codewords in C ⊥ . Then the system of linear inequalities in the variables x 1 , x 2 , . . . , x n given by\nis a system of facet-deﬁning inequalities comprising the min- imal polyhedral representation of P (C) iff C does not have as a minor any code equivalent to F ∗ 7 , R 10 or M ∗ (K 5 ) .\nThus, for a code C of length n, with d(C ⊥ ) / ∈ {1, 2} , and no F ∗ 7 , R 10 or M ∗ (K 5 ) minor, the number of facets of P (C) is\nwhere w H (u) is the Hamming weight of u. Thus, imple- menting ML decoding as an LP is truly an attractive option only when M(C ⊥ ) ◦ is of relatively small size, and consists of words of small Hamming weight relative to the codelength.\nIn the previous section, we saw that it is possible (with not insigniﬁcant effort) to characterize the facets of code polytopes, at least when the codes have no F ∗ 7 , R 10 or M ∗ (K 5 ) minor. But what information do we have about the other faces of P (C)? It is of course obvious that the vertices of P (C) are precisely the codewords of C. The edges of P (C) also have a simple characterization.\nTheorem 4.1 ([1], Theorem 5.1): Let C be a binary linear code. There is an edge connecting two distinct vertices c 1 and c 2 in P (C) iff c 1 ⊕ c 2 ∈ M(C) .\nThere is unfortunately (or fortunately for this author) very little known about faces of P (C) other than vertices, edges and facets. One might naturally ask why it is necessary to investigate faces in general. A reason we give is that it could help in understanding what happens when the code polytope is relaxed by removing some facets. A beautiful result of Figiel, Lindenstrauss and Milman [2, p. 275] states that there is a constant δ > 0 such that any centrally symmetric polytope P satisﬁes ln |V | · ln |F | ≥ δ dim(P ), where |V | and |F | denote the number of vertices and facets, respectively of P . In particular, it applies to the code polytope P (C) of a code C containing the all-ones word 1, and any of its relaxations obtained by throwing away facets while still maintaining central symmetry. Thus, for instance, the number of vertices and the number of facets in any of these polytopes cannot both be polynomial in the codelength. A more complete understanding of the facial structure of a code polytope and its relaxations can only help in improving such estimates of the number of vertices in terms of the number of facets. It may also be useful in the search for \u201cgood\u201d relaxations that introduce relatively few extra vertices.\nA code polytope is highly symmetric; it \u201clooks the same\u201d from any of its vertices. This symmetry is formally captured by the following statement, which essentially rephrases Theorem 3.1 from [1].\nLemma 4.2: For any binary linear code C, {c 1 , c 2 , . . . , c m } is the set of vertices of a k-face of P (C) iff {0, c 2 ⊕ c 1 , . . . , c m ⊕ c 1 } is the set of vertices of a k-face of P (C).\nThus, it is enough to study the structure of faces containing 0 , as an arbitrary face F of P (C) can be transformed, via\na symmetry of the n-cube n , to a face F containing 0 . Despite this high degree of symmetry, determining the complete facial structure of an arbitrary code polytope is a very difﬁcult problem, for which there is no known general solution. However, using Theorem 3.1 as a starting point, it is fairly easy to derive the facial structure in the important special case of the polytope of the [n, n − 1] even-weight code E n , as we now show.\nThe cases n = 1, 2, 3 are trivial: E 1 = P (E 1 ) = {0} ; E 2 = {00, 11} , hence P (E 2 ) = ∆ 1 ; and E 3 = {000, 011, 101, 110} , hence P (E 3 ) = ∆ 3 . The code polytopes for E n , n ≥ 4, are much more interesting, and Theorem 4.3 below, in conjunction with Lemma 4.2, gives their complete facial structure.\nWe introduce some simplifying pieces of notation. Given a positive integer n, we let [n] denote the set {1, 2, . . . , n} . If S is some set in R n , we let conv(S) denote its convex hull. For j = 1, 2, . . . , n, we deﬁne the hyperplanes H\n, and L j = {x ∈ R n : x j − s ∈[n],s=j x s = 0} .\nTheorem 4.3: For n ≥ 4, let E n denote the [n, n−1] binary even-weight code, so that M(E n ) is the set of binary words of length n and Hamming weight 2.\ncontaining 0 iff F = conv(0, a, b) for some a, b ∈ M(E n ) such that a ⊕ b is also in M(E n ) .\n(c) For 3 ≤ k ≤ n − 1, F is a k-face of P (E n ) containing 0 iff F = conv(E n ∩ V ) , where V is either\n(ii) j ∈J H j ∩L i for some J ⊂ [n] with |J| = n−k−1 and i ∈ [n] \\ J.\nSketch of Proof : Part (a) is a consequence of Theorem 4.1. For part (b), we ﬁrst observe that 2-dimensional 0/1-polytopes must either be triangles or quadrilaterals [14, Section 1.1]. We then show that no quadrilateral can be a 2-face of P (E n ) , and a triangle with vertices 0, a, b can be a 2-face of P (E n ) iff a , b, a ⊕ b ∈ M(E n ) .\nFor part (c), we note that the result for k = n − 1 follows from Theorem 3.1. 2 For the general result, we observe ﬁrst that a k-face incident with 0 must be contained in at least n − k facets incident with 0. We then make use of the result for k = n−1 to decide which intersections of n−k (or more) facets yields a k-face.\nn ∩ V ) for some V as in Theorem 4.3(c)(i) (resp. Theorem 4.3(c)(ii)). It is easy to see that k-faces of Type A are afﬁnely equivalent (via projection onto the coordinates x i , i /∈ J) to P (E k ) . Note that since P (E 3 ) = ∆ 3 , 3-faces of Type A are in fact afﬁnely equivalent to ∆ k . On the other hand, k-faces of Type B are always afﬁnely equivalent to the k-simplex ∆ k , due to the following corollary to the theorem.\nCorollary 4.4: F is a k-face of Type B iff F = conv(0, c 1 , c 2 , . . . , c k ) for c 1 , c 2 , . . . , c k ∈ M(E n ) such that\nCorollary 4.5: For k ≤ 3, all k-faces of P (E n ) are afﬁnely equivalent to ∆ k . For k > 3, a k-face of P (E n ) is afﬁnely equivalent to either P (E k ) or ∆ k .\nThe results presented so far in this section are enough to patch together a proof of the following useful result.\nTheorem 4.6: Fix an n ≥ 1, and let f k , 0 ≤ k ≤ n denote the number of n-faces of P (E n ) . We have f 0 = 2 n −1 , f 1 =\nThe vector (f 0 , f 1 , . . . , f n ) is called the f-vector of the polytope P (E n ) . It should be noted that f-vectors of polytopes are in general notoriously difﬁcult to compute.\nIt is interesting to note that the polytope P (E n ) only has triangular 2-faces. Code polytopes in general can have quadrilateral 2-faces as evidenced by the 2-faces of the n- cube, which is the code polytope of {0, 1} n . Examples of code polytopes with both kinds of 2-faces abound, one such being the [4, 3] code obtained as the direct sum of E 3 and {0, 1}.\nThis raises the question of whether any 0/1-polytope can arise as a face of some code polytope. This would make code polytopes a hopelessly complex class of polytopes. Indeed, there are classes of polytopes with this property, a celebrated example being the class of travelling salesman polytopes [3]. Luckily, code polytopes are not as complex. Up to afﬁne equivalence, there are eight types of 3-dimensional 0/1-polytopes [14, Section 1.1], of which only four are allowed to be 3-faces of code polytopes. We omit the proof.\nTheorem 4.7: If F is a 3-face of some code polytope, then up to afﬁne equivalence, F is one of the following: (i) the 3-cube 3 , (ii) the prism ∆ 2 × ∆ 1 , (iii) the square pyramid conv({000, 001, 010, 011, 111}), and (iv) the 3-simplex ∆\n. Remark: As examples, the prism ∆ 2 × ∆ 1 occurs as a 3- face of the [4,3] code that is the direct sum of E\nand {0, 1}, while the square pyramid occurs as a 3-face of the [5, 3] code with generator matrix\n1 0 0 1 0 0 1 0 0 1 0 0 1 1 1\nCuriously, Theorem 4.1 leads to a simple lower bound on the number of minimal codewords in a binary linear code C, which appears to be new.\nLemma 5.1: For any binary linear code C, |M(C)| ≥ dim(P (C)) . In particular, if C is a code of length n with d(C ⊥ ) / ∈ {1, 2} , then |M(C)| ≥ n.\nProof : The proof is simply the geometric fact that in any polytope P of dimension d, each vertex has at least d edges\nincident with it. By Theorem 4.1, the number of edges incident with any vertex of P (C) is exactly |M(C)|. It is natural to ask the question of when this bound is met with equality, and the following result provides the answer.\nTheorem 5.2: For any binary linear code C of length n with d(C ⊥ ) / ∈ {1, 2} , we have |M(C)| ≥ n, with equality iff C is the direct sum of simplex codes.\nWe give a proof that is essentially geometric, although it would be interesting to ﬁnd a purely coding-theoretic proof. In what follows, we let C be a code of length n with d(C ⊥ ) / ∈ {1, 2} , so that dim(P (C)) = n. By Theorem 4.1, |M(C)| = n iff each vertex of P (C) belongs to exactly n edges.\nA polytope of dimension n is called simple if each vertex of the polytope is incident with exactly n edges. 3 Thus, |M (C)| = n iff P (C) is simple. So, Theorem 5.2 is proved once we show the following lemma to be true.\nLemma 5.3: P (C) is simple iff C is the direct sum of simplex codes.\nA result of Kaibel and Wolff [7, Theorem 1] states that a 0/1-polytope is simple iff it is the (Cartesian) product of 0/1 -simplices (i.e., simplices whose vertices are in {0, 1} l for some l > 0). Therefore, the proof of Lemma 5.3, and hence that of Theorem 5.2, relies strongly on the next result.\nProof : The result is trivial when C ⊥ = {0} , as the code C = {0, 1} n is the direct sum of n copies of {0, 1}, which is degenerately a simplex code. So, assume that d(C ⊥ ) ≥ 3 .\nIf C is a [2 k − 1, k] simplex code, then P (C) is a (2 k − 1 )- dimensional polytope with 2 k vertices, which is a simplex. Conversely, if P (C) is a simplex of dimension n, it has\nn + 1 vertices. Hence, n + 1 = |C| = 2 k for some k, and so, n = 2 k − 1 . Let G be a k × (2 k − 1) generator matrix for C. Since d(C ⊥ ) ≥ 3 , the columns of G are nonzero and distinct. Therefore, the 2 k − 1 columns of G are the 2 k − 1 distinct nonzero binary words of length k, which means that G generates the [2 k − 1, k] simplex code.\nWe can now provide a proof of Lemma 5.3, which completes the proof of Theorem 5.2.\n, = 1, 2, . . . , r. Trivially, P (C) = P (C 1 ) × · · · × P (C r ) , and each P (C i ) is a simplex by Lemma 5.4. Hence, by the Kaibel-Wolff result [7], P (C) is simple.\nConversely, if P (C) is simple, then again by the Kaibel- Wolff result, P (C) = ∆ (1) × · · · × ∆ (r) for some simplices ∆ (1) , . . . , ∆ (r) . Letting C i denote the vertex set of ∆ (i) , i = 1, . . . , r , we observe that C = C 1 × · · · × C r . Since C is a linear code, it readily follows that each C i is a linear code. Thus, C is actually the direct sum of the C i \u2019s. It remains to show that each C i is a simplex code. Now, C\n, and so, the condition d(C ⊥ ) / ∈ {1, 2} implies that d(C ⊥ i ) / ∈ {1, 2} for each\ni . By deﬁnition, P (C i ) = conv(C i ) . But, conv(C i ) = ∆ (i) , since ∆ (i) is the convex hull of its vertex set. So, Lemma 5.4 shows that each C i is a simplex code. From a geometer\u2019s point of view, Lemma 5.3 is interesting by itself, as it provides a complete characterization of full- dimensional code polytopes that are simple. Another geomet- rically important class of polytopes is the class of simplicial polytopes, which are polytopes in which every facet is a simplex. The question of which code polytopes are simplicial remains open. A non-trivial example of such a polytope is polytope of the [6, 3] code generated by the matrix\n1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 0 1 1\nAs a ﬁnal remark, we would like to mention that simple polytopes play a crucial role in the performance analysis of simplex algorithms in linear programming [8]. A simplex algorithm is a method to solve an LP over a polyhedron P by repeatedly moving from one vertex of P to an adjacent vertex so that in each step the value of the objective function is decreased. Such an algorithm is not just easily described, but is also an efﬁcient general tool for solving LP\u2019s, and is the most promising candidate for a strongly polynomial time linear programming algorithm [6]. Our results on simple code polytopes could be useful in analyzing the performance of simplex algorithms for decoding by linear programming."},"refs":[{"authors":[{"name":"F. Barahona"},{"name":"M. Gr¨otschel"},{"name":"J. Comb. Theory Ser. B"},{"name":"A. Barvinok"},{"name":"L. Billera"},{"name":"A. Sarangarajan"},{"name":"J. Feldman"},{"name":"J. Wainwright"},{"name":"R. Karger"}],"title":{"text":"On the cycle polytope of a binary matroid,\u201d J. Comb. Theory Ser. B, vol. 40, pp. 40\u201362, 1986. [2] A. Barvinok, A Course in Convexity, Graduate Studies in Mathematics vol. 54, Providence, RI: AMS Publications, 2002. [3] L. Billera and A. Sarangarajan, \u201cAll 0-1 polytopes are traveling salesman polytopes,\u201d Combinatorica, vol. 16, no. 2, pp. 175\u2013188, 1996. [4] J. Feldman, M.J. Wainwright and D.R. Karger, \u201cUsing linear program- ming to decode binary linear codes"}},{"authors":[{"name":"G. Jeroslow"}],"title":{"text":"On deﬁning sets of vertices of the hypercube by linear inequalities"}},{"authors":[{"name":"V. Kaibel"},{"name":"R. Mechtel"},{"name":"M. Sharir"},{"name":"G. Ziegler"},{"name":"J. Comput."},{"name":"V. Kaibel"},{"name":"M. Wolff"},{"name":"J. Comb."},{"name":"G. Kalai"},{"name":"R. Koetter"},{"name":"W.-C.W. Li"},{"name":"O. Vontobel"}],"title":{"text":"The simplex algorithm in dimension three,\u201d SIAM J. Comput., vol. 34, no. 2, pp. 475\u2013497, 2005. [7] V. Kaibel and M. Wolff, \u201cSimple 0/1-polytopes,\u201d Europ. J. Comb., vol. 21, no. 326, pp. 139\u2013144, 2000. [8] G. Kalai, \u201cLinear programming, the simplex algorithm and simple polytopes,\u201d Math. Programming Ser. B, vol. 79, pp. 217\u2013233, 1997. [9] R. Koetter, W.-C.W. Li, P.O. Vontobel and J.L. Walker \u201cChar- acterizations of pseudo-codewords of LDPC codes"}},{"authors":[{"name":"J. MacWilliams"},{"name":"A. Sloane"},{"name":"O. Vontobel"},{"name":"R. Koetter"},{"name":"O. Vontobel"},{"name":"R. Smarandache"},{"name":"N. Kiyavash"},{"name":"J. Teutsch"},{"name":"D. Vuko- bratovic"}],"title":{"text":"Graph-cover decoding and ﬁnite-length analysis of message-passing iterative decoding of LDPC codes,\u201d preprint submitted to IEEE Trans. Inform. Theory, Dec. 2005. ArXiv e-print cs.IT/0512078. [12] P.O. Vontobel, R. Smarandache, N. Kiyavash, J. Teutsch and D. Vuko- bratovic, \u201cOn the minimal pseudo-codewords of codes from ﬁnite geometries"}},{"authors":[{"name":"G. Ziegler"}],"title":{"text":"Lectures on 0/1-Polytopes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/ita2013/82"},"links":[{"id":"205","weight":18},{"id":"2760","weight":8},{"id":"1486","weight":3},{"id":"2741","weight":3},{"id":"3180","weight":5},{"id":"67","weight":4},{"id":"2206","weight":9},{"id":"1606","weight":8},{"id":"153","weight":26},{"id":"3037","weight":9},{"id":"93","weight":6},{"id":"436","weight":9},{"id":"3191","weight":9},{"id":"223","weight":3},{"id":"1547","weight":6},{"id":"2254","weight":11},{"id":"1278","weight":5},{"id":"2287","weight":2},{"id":"3200","weight":13},{"id":"3008","weight":9},{"id":"3083","weight":8},{"id":"2217","weight":9},{"id":"3010","weight":11},{"id":"3222","weight":4},{"id":"2291","weight":2},{"id":"307","weight":3},{"id":"1430","weight":6},{"id":"3021","weight":18},{"id":"170","weight":18},{"id":"3199","weight":6},{"id":"813","weight":4},{"id":"3069","weight":2},{"id":"2634","weight":4},{"id":"526","weight":8},{"id":"2442","weight":8},{"id":"3183","weight":2},{"id":"175","weight":3},{"id":"362","weight":4},{"id":"2763","weight":3},{"id":"2534","weight":6},{"id":"1235","weight":3},{"id":"135","weight":5},{"id":"404","weight":2},{"id":"702","weight":8},{"id":"450","weight":32},{"id":"770","weight":9},{"id":"3165","weight":4},{"id":"1082","weight":18},{"id":"3182","weight":3},{"id":"1889","weight":5},{"id":"3154","weight":3},{"id":"2002","weight":9},{"id":"3065","weight":5},{"id":"3195","weight":16},{"id":"1060","weight":12},{"id":"3132","weight":5},{"id":"1160","weight":4},{"id":"3187","weight":7},{"id":"475","weight":3},{"id":"3137","weight":12},{"id":"3059","weight":6},{"id":"2646","weight":4},{"id":"104","weight":17},{"id":"90","weight":6},{"id":"236","weight":3},{"id":"117","weight":6},{"id":"273","weight":7},{"id":"3111","weight":5},{"id":"1442","weight":9},{"id":"2745","weight":4},{"id":"2276","weight":5},{"id":"2352","weight":6},{"id":"3176","weight":8},{"id":"3255","weight":21},{"id":"470","weight":6},{"id":"1643","weight":4},{"id":"250","weight":5},{"id":"3036","weight":2},{"id":"163","weight":2},{"id":"26","weight":16},{"id":"2455","weight":2},{"id":"1298","weight":6},{"id":"3175","weight":2},{"id":"3201","weight":15},{"id":"1268","weight":6},{"id":"2830","weight":14},{"id":"679","weight":6},{"id":"3135","weight":4},{"id":"3049","weight":11},{"id":"1479","weight":2},{"id":"1215","weight":14},{"id":"1223","weight":3},{"id":"107","weight":7},{"id":"1473","weight":4},{"id":"217","weight":8},{"id":"1462","weight":13},{"id":"3038","weight":5},{"id":"1996","weight":22},{"id":"325","weight":3},{"id":"1458","weight":3},{"id":"2025","weight":2},{"id":"973","weight":5},{"id":"1279","weight":8},{"id":"2119","weight":5},{"id":"888","weight":4},{"id":"1436","weight":4},{"id":"459","weight":11},{"id":"155","weight":2},{"id":"1877","weight":8},{"id":"3186","weight":8},{"id":"3072","weight":18},{"id":"306","weight":20},{"id":"1121","weight":3},{"id":"3057","weight":3},{"id":"3068","weight":20},{"id":"3164","weight":4},{"id":"1107","weight":7},{"id":"2697","weight":4},{"id":"398","weight":22},{"id":"152","weight":4},{"id":"2750","weight":10},{"id":"3105","weight":28},{"id":"2178","weight":4},{"id":"1866","weight":6},{"id":"3233","weight":4},{"id":"2488","weight":6},{"id":"900","weight":4},{"id":"59","weight":5},{"id":"353","weight":8},{"id":"1846","weight":12},{"id":"1074","weight":6},{"id":"3168","weight":11},{"id":"263","weight":8},{"id":"2751","weight":8},{"id":"1103","weight":15},{"id":"3157","weight":20},{"id":"2317","weight":6},{"id":"572","weight":3},{"id":"76","weight":7},{"id":"372","weight":4},{"id":"3073","weight":7},{"id":"54","weight":5},{"id":"1660","weight":4},{"id":"628","weight":4},{"id":"408","weight":2},{"id":"3005","weight":9},{"id":"1696","weight":9},{"id":"1212","weight":8},{"id":"2324","weight":9},{"id":"487","weight":4},{"id":"508","weight":19},{"id":"65","weight":4},{"id":"3027","weight":5},{"id":"71","weight":4},{"id":"642","weight":9},{"id":"3196","weight":8},{"id":"2033","weight":4},{"id":"1830","weight":6},{"id":"202","weight":4},{"id":"2740","weight":8},{"id":"1443","weight":10},{"id":"3202","weight":20},{"id":"2812","weight":12},{"id":"3243","weight":5},{"id":"3134","weight":21},{"id":"445","weight":10},{"id":"3185","weight":4},{"id":"1671","weight":7},{"id":"1325","weight":11},{"id":"1844","weight":13},{"id":"219","weight":5},{"id":"428","weight":20},{"id":"2174","weight":8},{"id":"2759","weight":8},{"id":"1128","weight":8},{"id":"2319","weight":2},{"id":"431","weight":4},{"id":"676","weight":3},{"id":"1376","weight":6},{"id":"1448","weight":6},{"id":"3056","weight":8},{"id":"1","weight":5},{"id":"2617","weight":13},{"id":"2435","weight":2},{"id":"3174","weight":19},{"id":"3051","weight":9},{"id":"1840","weight":8},{"id":"1988","weight":11},{"id":"1908","weight":6},{"id":"2884","weight":18},{"id":"771","weight":2},{"id":"3088","weight":10},{"id":"25","weight":7},{"id":"658","weight":2},{"id":"2743","weight":5},{"id":"687","weight":4},{"id":"230","weight":5},{"id":"3123","weight":11},{"id":"309","weight":2},{"id":"2773","weight":4},{"id":"31","weight":6},{"id":"3071","weight":4},{"id":"503","weight":14},{"id":"3163","weight":3},{"id":"1439","weight":11},{"id":"278","weight":11},{"id":"764","weight":17},{"id":"3113","weight":3},{"id":"1444","weight":3},{"id":"151","weight":3},{"id":"887","weight":8},{"id":"95","weight":2},{"id":"1109","weight":8},{"id":"1438","weight":3},{"id":"184","weight":2},{"id":"264","weight":8},{"id":"257","weight":7},{"id":"3030","weight":8},{"id":"694","weight":6},{"id":"1573","weight":9},{"id":"203","weight":10},{"id":"525","weight":2},{"id":"1847","weight":6},{"id":"3205","weight":9},{"id":"1509","weight":4},{"id":"3108","weight":4},{"id":"1836","weight":2},{"id":"3167","weight":8},{"id":"1822","weight":2},{"id":"275","weight":3},{"id":"376","weight":5},{"id":"308","weight":11},{"id":"2838","weight":3},{"id":"3197","weight":13},{"id":"630","weight":13},{"id":"767","weight":5},{"id":"326","weight":6},{"id":"2939","weight":4},{"id":"1076","weight":20},{"id":"430","weight":3},{"id":"1915","weight":4},{"id":"1233","weight":3},{"id":"641","weight":11},{"id":"1905","weight":9},{"id":"3189","weight":17},{"id":"575","weight":8},{"id":"831","weight":23},{"id":"2862","weight":4},{"id":"402","weight":3},{"id":"371","weight":9},{"id":"2443","weight":4},{"id":"1084","weight":3},{"id":"2729","weight":2},{"id":"423","weight":2},{"id":"2316","weight":9},{"id":"3156","weight":11},{"id":"1883","weight":8},{"id":"3074","weight":3},{"id":"1102","weight":14},{"id":"2173","weight":5},{"id":"1517","weight":6},{"id":"198","weight":2},{"id":"1319","weight":4},{"id":"699","weight":7},{"id":"506","weight":17},{"id":"187","weight":7},{"id":"165","weight":10},{"id":"2255","weight":5},{"id":"1627","weight":12},{"id":"92","weight":5},{"id":"705","weight":6},{"id":"3070","weight":8},{"id":"1503","weight":14},{"id":"438","weight":4},{"id":"3181","weight":8},{"id":"1546","weight":5},{"id":"3198","weight":2},{"id":"2778","weight":8},{"id":"1098","weight":7},{"id":"1861","weight":2},{"id":"220","weight":3},{"id":"660","weight":9},{"id":"183","weight":5},{"id":"688","weight":4},{"id":"3129","weight":4},{"id":"3169","weight":6},{"id":"359","weight":7},{"id":"1930","weight":6},{"id":"3173","weight":19},{"id":"288","weight":5},{"id":"1553","weight":10},{"id":"3184","weight":6},{"id":"3044","weight":4},{"id":"3170","weight":7},{"id":"485","weight":4},{"id":"3193","weight":13},{"id":"2738","weight":11},{"id":"240","weight":2},{"id":"1166","weight":3},{"id":"1550","weight":6},{"id":"211","weight":8},{"id":"782","weight":5},{"id":"2495","weight":4},{"id":"420","weight":2},{"id":"323","weight":3},{"id":"3136","weight":6},{"id":"74","weight":3},{"id":"243","weight":7},{"id":"1231","weight":3},{"id":"1214","weight":12},{"id":"1083","weight":13},{"id":"1434","weight":9},{"id":"1871","weight":3},{"id":"3188","weight":6},{"id":"3177","weight":9},{"id":"643","weight":2},{"id":"3166","weight":6},{"id":"449","weight":5},{"id":"377","weight":7},{"id":"424","weight":9},{"id":"3029","weight":8},{"id":"3151","weight":18},{"id":"229","weight":16},{"id":"2146","weight":15},{"id":"2638","weight":10},{"id":"2315","weight":6},{"id":"1423","weight":11},{"id":"1680","weight":25},{"id":"3208","weight":13},{"id":"370","weight":4},{"id":"2299","weight":8},{"id":"1258","weight":9},{"id":"2288","weight":5},{"id":"2340","weight":9},{"id":"2286","weight":4},{"id":"2038","weight":8},{"id":"2448","weight":6},{"id":"752","weight":18},{"id":"1393","weight":6},{"id":"1300","weight":3},{"id":"1714","weight":6},{"id":"3162","weight":8}],"meta":{"jsonClass":"Map$Map3","room":"The Cocatoo","date":"1360689000000","session":"1"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
