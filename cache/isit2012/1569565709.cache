{"id":"1569565709","paper":{"title":{"text":"On Symmetric L 1 distance error control codes and elementary symmetric functions"},"authors":[{"name":"Luca G. Tallini"},{"name":"Bella Bose"}],"abstr":{"text":"Abstract\u2014Based on the elementary symmetric functions, this paper gives a new wide class of Goppa like codes capable of correcting/detecting errors measured under the (symmetric) L 1 distance deﬁned over the m-ary words, 2 ≤ m ≤ +∞. All these codes can be efﬁciently decoded by algebraic means with the Extended Euclidean Algorithm (EEA). In particular it is shown that if K is any ﬁeld with characteristic char(K) = 2, m ∈ IIN ∪ {+∞} and n, t ∈ IIN then there exist m-ary codes C of length n ≤ (|K| − 1)/2 and cardinality |C| ≥ m n /|K| t which are capable of, say, correcting t errors (i. e., the minimum L 1 distance of C is d L 1 (C) ≥ 2t + 1) with t steps of EEA. Also, if K is a ﬁnite ﬁeld and 2t + 1 ≤ char(K) = 2 then some of these codes are (essentially) linear and, hence, easy to encode.\nIndex Terms\u2014m-ary alphabet, error control codes, symmetric errors, asymmetric errors, ﬂash memories, insertion and deletion errors, repetition errors. L 1 distance, Lee distance."},"body":{"text":"Let ZZ m def = {0, 1, . . . , (m−1)} be the m-ary alphabet, m = 2, 3, . . . , +∞; where we let ZZ +∞ def = IIN = {0, 1, 2, . . .}. The L 1 distance between two m-ary words of length n ∈ IIN, X = x 1 x 2 . . . x n ∈ ZZ n m and Y = y 1 y 2 . . . y n ∈ ZZ n m , is deﬁned as\nwhere X and Y are regarded as n component vectors over the real ﬁeld IR, and |d| indicates the absolute value of d ∈ IR. For example, if m = 5, n = 6, X = 012314 and Y = 443101 then d L 1 (X, Y ) = |0 − 4| + |1 − 4| + |2 − 3| + |3 − 1| + |1 − 0| + |4 − 1| = 4 + 3 + 1 + 2 + 1 + 3 = 14. Such error control (EC) codes for the L 1 metric are fundamental whenever the transmission channel is characterized by an error probability of P r(symbol y is received | symbol x is sent) ≈ |x−y| , for all x, y ∈ {0, 1, . . . , m−1} ⊆ IR and x = y, where ∈ [0, 1] ⊆ IR + is a small constant. Some practical examples of physical channel with the above error probability are the multi-level ﬂash memories [1], [5], [6] and the repetition channels [8]. In [9], [7], [5] and [6], regarding m-ary words as submultisets of a multiset, new algebraic decoding procedures for a very wide class of new and previously known EC codes are given. Such decoding procedures are based on ﬁnding the solution of a general key equation involving the elementary symmetric functions (instead of the power sums) of the received word and the unknown coefﬁcients of some error evaluator polynomials. In the above cited papers it is shown how the general key equa- tion can be used to decode BCH, Goppa and Alternant codes to control symmetric errors counted in the usual Hamming\ndistance. Furthermore, it is also shown how to decode some of these codes and other new ones to combat the errors due to the transmission through possibly asymmetric channels. In these decoding schemes, the number of errors are counted in the L 1 metric by taking into account the directionality of the errors (that is, if the errors are negative or positive). This is done by introducing the (t + , t − )-EC/(d + , d − )-ED codes [5]. Here, it is shown how the same framework based on computing the elementary symmetric functions of the received word is helpful in designing new codes capable of correcting/detecting symmetric errors counted in the L 1 distance (1). Section II clariﬁes this concept of symmetric errors in the L 1 metric. Here, we use the elementary symmetric function framework in a Berlekamp like construction of EC code for the Lee metric [2, Ch. 9], [3, Sec. 10.6]. In this way, we get the new class of Goppa like t symmetric EC (t-SyEC) codes for the L 1 metric deﬁned in Section III. All these codes can be decoded efﬁciently by algebraic means with the Extended Euclidean Algorithm (EEA). Some of these codes can be very efﬁciently encoded too, and this is shown in Section IV. For example, a code of length n = 5 is given with r = 3 check 11- ary digits computed as a linear combination in GF (11) of k = 2 information 16-ary (hexadecimal) digits (however the information digits can be of any alphabet size). This code is capable of correcting t = 3 symmetric errors in the L 1 metric. In [4], we successfully reduce the problem of designing Lee distance EC codes to the code constructions given here for the L 1 distance. Due to space limitation some of the proofs of the theorems given here are omitted.\nLet us ﬁx some useful notation. If X = x 1 . . . x n ∈ ZZ n m is any word of length n over the m-ary alphabet ZZ m then let supp(X) def = supp I (X) indicate a subset of the index set I def = [1, n] def = {1, 2 . . . , n} where every element i ∈ [1, n] is counted with its multiplicity, m X (i) = x i ∈ ZZ m ⊆ IIN, given by the i-th component of X. Namely, X ≡ supp(X) is a multiset on [1, n], and we simply let the weight of X to be w(X) = |X| = |supp(X)| = i∈[1,n] x i = i∈[1,n] m X (i). For example, if m = 3, n = 4 and X = 2012 ∈ ZZ 4 3 then x 1 = m X (1) = 2, x 2 = m X (2) = 0, x 3 = m X (3) = 1, x 4 = m X (4) = 2, supp(X) = {1, 1, 3, 4, 4} and the weight of X is w(X) = |supp(X)| = i∈[1,n] m X (i) = 5. Let ∂X def = ∂ I X def = {i ∈ I = [1, n] : x i = m X (i) = 0} ∈ ZZ n 2 be the set of indices where X is different from 0 and note that ∂X can be regarded as a subset of [1, n]. We refer to ∂X as the index set of X. The multiset supp(X) should not be confused\nwith the index set (which is a proper set), ∂X, of X. Note that the usual Hamming weight of X is w H (X) = |∂X|, and supp(X) = ∂X if, and only if, X ∈ ZZ n 2 . For example if X = 2012, ∂X = 1011 ≡ {1, 3, 4} ⊆ [1, 4] and w H (X) = |∂X| = 3 = |supp(X)| = w(X) = 5. Let the integer scalar product between c ∈ IIN and X = x 1 x 2 . . . x n ∈ ZZ n m ⊆ IIN n be deﬁned as c · X = cx 1 cx 2 . . . cx n ∈ ZZ n c(m−1)+1 ⊆ IIN n . For example, if X = 2012 ∈ ZZ 4 3 ⊆ IIN 4 then 3 · X = 6036 ∈ ZZ 4 7 ⊆ IIN 4 .\nDeﬁne the total order in ZZ m as 0 ≤ 1 ≤ 2 ≤ . . . ≤ (m − 1) and, for all x, y ∈ ZZ m , let the minimum (maximum) operation min(x, y) (max(x, y)) be deﬁned as the minimum (maximum) between x and y, let the natural subtraction operation in ZZ m be deﬁned as x . − y def = 0 if x ≤ y, and x . − y def = x − y if x > y, where \u201c−\u201d indicates the usual integer subtraction. Then given any two words/multisets X, Y ∈ ZZ n m , the words/multiset operations X ∩ Y ∈ ZZ n m , X ∪ Y ∈ ZZ n m , X + Y ∈ IIN, and X . − Y ∈ ZZ n m are deﬁned as the digit by digit min, max, integer addition and . − operation between X and Y , respectively. For example, if m = 3, n = 8, X = 012012012 and Y = 000111222 then X ∩ Y = 000011012, X ∪ Y = 012112222, X + Y = 012123234, X . − Y = 012001000 and\nY . − X = 000100210. Given any two word X, Y ∈ ZZ n m , we say that X is contained in Y and write X ⊆ Y if, and only if, X = X ∩ Y . For example, 000011012 ≡ {5, 6, 8, 9, 9} ⊆ {2, 3, 3, 5, 6, 6, 8, 9, 9} ≡ 012012012. Note that the relation ⊆ deﬁnes a partial ordering in the family of multisets on [1, n] with multiplicity at most m − 1 (≡ the sets of m-ary words of length n). Under this multiset interpretation, an m-ary generalization of the binary Hamming distance between two words/submultisets X and Y can be deﬁned as the \u201csymmetric distance\u201d\nwhich is nothing but the L 1 distance deﬁned in (1). For example, if X = 012012012 = {2, 3, 3, 5, 6, 6, 8, 9, 9} and Y = 000111221 = {4, 5, 6, 7, 7, 8, 8, 9} then X . − Y = 012001001 = {2, 3, 3, 6, 9} and Y . − X = 000100210 = {4, 7, 7, 8}, and so, d L 1 (X, Y ) = 9. In the above deﬁnitions there is nothing special in choosing I = [1, n] as index set. In fact, any other set will do.\nDeﬁnition 1: Given X, Y ∈ ZZ n m , we say that Y is obtained from X due to t + ∈ IIN positive errors and t − ∈ IIN negative errors if, and only if, |Y . − X| = t + and |X . − Y | = t − . Also, we say that Y is obtained from X due to t ∈ IIN symmetric errors if, and only if, d S (X, Y ) = t.\nGiven Deﬁnition 1, the following theorem holds on symmetric error correcting/detecting codes for the L 1 distance.\nTheorem 1: A code C ⊆ ZZ n m is capable of correcting t or less symmetric errors and simultaneously detecting d or less symmetric errors (i. e., C is a t-SyEC/d-SyED code), with t, d ∈ IIN, t ≤ d if, and only if, the minimum symmetric distance of C is\nLet K be any ﬁeld. For all polynomials (or, more generally, power series) p(z) def = p 0 + p 1 z + p 2 z 2 + p 3 z 3 + . . . ∈ K[z], let p ev (z) def = p 0 + p 2 z 2 + . . . ∈ K[z] indicate the even part of p(z) and p od (z) def = p 1 z + p 3 z 3 + . . . ∈ K[z] the odd part. We say that a polynomial is even (odd) iff, p(z) = p ev (z) (p(z) = p od (z), respectively). If a polynomial is neither even nor odd then we call it mixed; otherwise, we call it unmixed. Note that\np(z) = p ev (z) + p od (z), p ev (−z) = p ev (z),\nWe let deg(p) ∈ IIN ∪ {−∞} indicate the degree of any polynomial p(z) ∈ K[z]. Given the ﬁeld K, let K + ⊆ K be the biggest subset of K such that a ∈ K + =⇒ −a ∈ K + . We refer to K + as the subset of positive elements in K. Let K − def = K − ({0} ∪ K + ) be the subset of negative elements in K and note that K remains partitioned as follows: K = K − ∪ {0} ∪ K + . Let S + ∈ ZZ n m be a multiset over K such that ∂S + = {a 1 , a 2 , . . . , a n } ⊆ K + . In this way, ∂S − def = {−a 1 , −a 2 , . . . , −a n } ⊆ K − , where the multiset S − ∈ ZZ n m over K is deﬁned by m S − (−a i ) def = m S + (a i ), for all natural i ∈ [1, n]. Furthermore, let ∂S def = ∂S − ∪ ∂S + ⊆ K and S def = S − ∪ S + ∈ ZZ 2n m . As in [5]\u2013[9], for all X ⊆ S + , let σ X (z) ∈ K[z] be the polynomial associated with X,\nwith σ ev X (z) def = 1 + σ 2 (X)z 2 + . . . and σ od X (z) def = σ 1 (X)z + σ 3 (X)z 3 + . . .. We will use the general theorem given below.\nTheorem 2: Let K be any ﬁeld, S ∈ ZZ n m be a multiset with index set ∂S = {a 0 , a 1 , . . . , a n−1 } ⊆ K and σ X (z) def = z x 0 n−1 i=1 (1 − a i z) x i , for all X ⊆ S. Then, for all X, Y ⊆ S, σ X+Y (z) = σ X (z)σ Y (z).\nNow, the following theorem deﬁnes a wide family of minimum symmetric L 1 distance code of considerable cardinality.\nTheorem 3: Let K be any ﬁeld, S + , S − ∈ ZZ n m , ∂S + = {a 1 , a 2 , . . . , a n } ⊆ K + , ∂S − = {−a 1 , −a 2 , . . . , −a n } ⊆ K − , ∂S = ∂S − ∪ ∂S + ⊆ K be deﬁned as above and σ X (z) be deﬁned as in (3). Let g(z) ∈ K[z] be any polynomial over K such that gcd(σ ∂S , g) = 1 (otherwise, just consider as g the polynomial g/ gcd(σ ∂S , g)). Then, for all σ(z) ∈ K[z] the code of length n = |S + | ≤ (|K| − 1)/2 deﬁned as\neither contains at most one element or many elements with minimum symmetric distance\nFurthermore, if C σ,g (S + ) = ∅ then (we let gcd(0, g)(z) = g for all g(z) ∈ K[z])\nSo, there exists a polynomial σ(z) ∈ Φ(g) def = {q(z) ∈ K[z] : deg(q) < deg(gcd(g ev , g od )), q(z) satisﬁes (5) and C q,g (S + ) = ∅} such that\nProof: First, from Theorem 4 in [5], the following key equation holds. For all X, Y ⊆ S + ,\nσ ev X∪Y (z) = σ X (z) − σ od X (z) σ ev Y . −X (z) + σ od X (z)σ od Y . −X (z) = σ X (z)σ ev Y . −X (z) − σ od X (z)σ Y . −X (−z) =\n    \n   \nσ Y (z)σ ev X . −Y (z) − σ od Y (z)σ X . −Y (−z), σ X (z)σ od Y . −X (z) + σ od X (z)σ Y . −X (−z) =\nNow assume X ∈ C σ,g (S + ). In this case, from (4) and (8) taken mod g(z), it follows\n     \n    \nσ Y (z)σ ev X . −Y (z) − σ od Y (z)σ X . −Y (−z) mod g(z), σ X (z) σ od Y . −X (z) + σ(z)σ Y . −X (−z) =\nSince X ⊆ S and gcd(σ ∂S , g) = 1 it follows that σ X (z) is invertible mod g(z). So, the above system and (2) imply\nHence, letting τ E (z) def = σ Y . −X (−z)σ X . −Y (z), from (2), (9) and σ Y − 2σ od Y = σ ev Y + σ od Y − 2σ od Y = σ ev Y − σ od Y , it follows,\nNow, let Y − ⊆ S − be the multiset whose vector representation is (the same as that of) Y but whose index set is S − ; that is, Y − = supp ∂S − Y . Since Y ⊆ S − ⊆ S and gcd(σ ∂S , g) = 1 it follows that σ Y (−z) = σ Y − (z) is invertible mod g(z). Hence, the above equation imply\n(z) σ Y (−z)\n(1−a i z) x i . −y i because of (3). Note that, if X ∈ C σ,g (S + ) is sent and Y ⊆ S + is received then τ E (z) is an error evaluator polynomial of the error pattern E = (Y . − X) − (X . − Y ) = Y − X with deg(τ E ) = |Y . − X| + |X . − Y | = |Y − X| =\nd S (X, Y ). In fact, by construction, a ∈ S + (a ∈ S − ) and τ E (1/a) = 0 with multiplicity e ∈ ZZ m if, and only if, a ∈ X . − Y (a ∈ Y . − X, respectively) with multiplicity e. Now, if also Y ∈ C σ,g (S + ) then σ(z)σ Y (z) − σ od Y = 0 mod g(z) and so, from (10), τ od E (z) = 0 mod g(z). Hence, either deg(g) ≤ deg(τ od E ) ≤ deg(τ E ) = d S (X, Y ) or τ od E (z) ≡ 0. In the latter case τ E (z) is even, hence, if there exists a ∈ S + such that τ E (1/a) = 0 then τ E (1/(−a)) = 0 and so a ∈ (X . − Y ) ∩ (Y . − X) = ∅, which is absurd. The only alternative is that τ E (z) ≡ 1 which means (X . − Y ) = (Y . − X) = ∅ and so X = Y . This proves deg(g) ≤ d S (C σ,g (S + )).\nNow we show that if C σ,g (S + ) = ∅ then relation (5) holds. If X ∈ C σ,g (S + ) = ∅ then σ od X (z) = σ(z)σ X (z) mod g(z), and so, σ(z)σ X (z)−σ od X (z) = k(z)g(z) for some k(z) ∈ K[z]. By splitting the even and odd parts we get\nHence, by letting ˜ g(z) def = gcd(g ev , g od )(z) ∈ K[z] and δ(z) def = σ ev (z)(σ ev (z) − 1) − [σ od (z)] 2 ∈ K[z] we have\nσ ev σ ev X + \t σ od \t σ od X = 0 mod ˜ g, σ od σ ev X + (σ ev − 1) σ od X = 0 mod ˜ g,\nand so δσ ev X = 0 mod ˜ g and δσ od X = 0 mod ˜ g. However this implies δ(z)σ X (z) = 0 mod ˜ g(z) because, from (2), σ X (z) = σ ev X (z) + σ od X (z). Now, from the hypothesis of the theorem gcd(σ ∂S , g) = 1, it follows gcd(σ X , g) = 1 because X ⊆ S + ⊆ S. Also, g(z) = g ev (z) + g od (z) is a multiple of ˜ g(z) = gcd(g ev , g od ), and so gcd(σ X , g) is a multiple of gcd(σ X , ˜ g). These facts imply gcd(σ X , ˜ g) = 1, and so σ X (z) is invertible mod ˜ g(z). So, we have shown that if there exists X ∈ C σ,g (S + ) = ∅ then δ(z)σ X (z) = 0 mod ˜ g(z) and σ X (z) is invertible mod ˜ g(z). But this implies that δ(z) = 0 mod ˜ g(z), which is equivalent to (5) because δ(z) = σ ev (z)(σ ev (z)−1)−[σ od (z)] 2 = σ(z)σ(−z)−σ ev (z). Relation (6) follows from (5) and the pigeon principle.\nGiven t, d ∈ IIN with t + d < deg(g), Algorithm 1 is an efﬁ- cient decoding algorithm for t-SyEC/d-SyED based on solving (10) in the unknown polynomial τ E (z) = τ ev E (z) + τ od E (z).\nAlgorithm 1 (t-SyEC/d-SyED decoding for C σ,g in (4)): Input: The received word Y ∈ ZZ n m .\nOutput: The original word X ∈ C σ,g (S + ) or detect signal. Assume that deg(g) > t + d.\nS1: Compute c Y (z) = [σ(z)σ Y (z) − σ od Y (z)]/σ Y (−z) mod g(z) as the syndrome of the received word Y .\nS2: Based on (10), ﬁnd the minimal solution (α(z), β(z)), with α(z), β(z) ∈ K[z], to the problem\nThis can be accomplished either with the Extended Euclidean Algorithm (see [9, Theorem 4]), or with any other method.\nS3: Set τ E (z) = β(z) and compute the error vector E = (Y . − X) − (X . − Y ) = Y − X from τ E (z) = σ Y . −X (−z)σ X . −Y (z)\nas follows. For all a ∈ ∂S = ∂S − ∪ ∂S + , in the order execute (note that p(a) = 0 with multiplicity 0 means p(a) = 0): 1) if a ∈ ∂S − and τ E (1/a) = 0 with multiplicity e ∈ ZZ m then set m X . −Y (−a) = 0 and m Y . −X (−a) = e; 2) if a ∈ ∂S + and τ E (1/a) = 0 with multiplicity e ∈ ZZ m then set m X . −Y (a) = e. S4: Compute X = Y − E.\nS5: If X ∈ C σ,g (S + ) and d S (X, Y ) = |E| ≤ t then output the detect signal equal to 0, output X and exit.\nTheorem 1 and Theorem 3 imply that Algorithm 1 is correct. Now, some examples are given to illustrate the code design. Example 1 (g(z) = z 2t+1 ∈ K[z], t ∈ IIN): Let m ∈ IIN, K\nbe any ﬁeld with characteristic char(K) = 2, g(z) = z 2t+1 , t ∈ IIN, and S + = (m − 1)∂S + with ∂S + ⊆ K + . In this case, since g is unmixed, it follows gcd(g ev , g od ) = g, and so, by equating the coefﬁcients in (5), if σ(z) = σ 0 + σ 1 z + . . . + σ 2t z 2t ∈ Φ(g) then σ 0 = σ 2 0 and σ 2i = 2σ 0 σ 2i + 2i−1 j=1 (−1) j σ j σ 2i−j , for all integer i ∈ [1, t]. From σ 0 = σ 2 0 , it follows σ 0 = 0 or 1. However, if X ∈ C σ,g (S + ) = ∅ then σ 0 = 1 because σ X (0) = 1, g(0) = σ od X (0) = 0 and σ od X (z) = σ(z)σ X (z) + k(z)g(z), with k(z) ∈ K[z]. Hence, if σ(z) ∈ Φ(g) then σ od (z) = σ 1 z + σ 3 z 3 + . . . + σ 2t−1 z 2t−1 ∈ K[z] might be chosen arbitrarily but σ ev (z) = σ 0 + σ 2 z 2 + . . . + σ 2t z 2t ∈ K[z] is uniquely identiﬁed by the t + 1 quadratic equations\nσ 6 = −2σ 1 σ 5 + 2σ 2 σ 4 − σ 2 3 , .. .\nWhen char(K) > 0, this implies |Φ(g)| ≤ |K| t because (σ 1 , σ 3 , . . . , σ 2t−1 ) ∈ K t (otherwise, if char(K) = 0 then Φ(g) depends on at most t parameters in K). Hence, by letting T = ZZ n m and S + = (m − 1)∂S + ∈ ZZ n m in Theorem 3, it follows that there exists a code C σ,g (S + ) of length n = |∂S + | ≤ (|K| − 1)/2 with d S (C σ,g (S + )) ≥ deg(g) = 2t + 1 and |C σ,g (S + )| ≥ m n /|K| t (that is, the redundancy is ρ(C σ,g (S + )) def = n − log m |C σ,g (S + )| ≤ t log m |K|).\nExample 2 (g(z) = z 2t+1 − az 2t−1 ∈ K[z], t ∈ IIN): Let us assume the same hypothesis of Example 1 but ∂S + ⊆ K + − {a} and g(z) = z 2t+1 −az 2t−1 . As Example 1, the polynomial σ(z) of degree at most 2t is in Φ(g) only if σ od (z) ∈ K[z] may be chosen arbitrarily but the coefﬁcients of σ ev (z) ∈ K[z] satisfy the t + 1 quadratic equations\n0 = a t σ 2 2t + bσ 2t + c, \t (12) where\nNote that the coefﬁcient σ 0 , σ 2 , . . . , σ 2t−2 ∈ K are uniquely determined by (σ 1 , σ 3 , . . . , σ 2t−1 ) ∈ K t and the t equations of (11), whereas σ 2t ∈ K must satisfy the uniquely determined quadratic equation (12). Let the discriminant ∆ def = b 2 − 4a t c, with b and c given by (13). Now, depending on ∆ ∈ K being a square, 0 or not a square in K, the equation (12) has 2, 1 or 0 solutions for σ 2t ∈ K. Note that, for example, if t = 1 then b = −1, c = −σ 2 1 and, so, ∆ = 1 + 4aσ 2 1 . If t = 2 then b = 2aσ 2 −1, c = σ 2 2 −2σ 1 σ 3 −aσ 2 3 and, so, ∆ = 1+4a(σ 1 +aσ 3 ) 2 . Likewise, if t = 3 then ∆ = 1 + 4a(σ 1 + aσ 3 + a 2 σ 4 ) 2 . Based on this, for various ﬁelds K = GF (p), p odd prime, we have noticed that if a is a square then the number of different solutions to (5) is |K| t − |K| t−1 ≥ |Φ(g)| for t = 1, 2, 3. We suspect this to be true in general for all t and K. For example, if K = GF (11), t = 2, n = 4 = |∂S + | ≤ (|K| − 1)/2 − 1\nthen |Φ(g)| ≤ |K| 2 − |K| = 121 − 11 = 110 (found with a spreadsheet application). So, if T = ZZ n m and S + = (m − 1)∂S + ∈ ZZ n m then the lower bound in the Theorem 3 gives a code of length n = 4 with d S (C σ,g (S + )) ≥ 5 containing |C σ,g (S + )| ≥ m 4 /(|K| 2 − |K|) = m 4 /110. If m = 11 (but m can be any) then |C σ,g (S + )| ≥ 11 4 /110 = 134.\nNote that the codes deﬁned in Theorem 3 might be far from being linear (and hence, it may not be easy to encode). However some of them are linear/essentially linear (in the sense of [5]) and, so, they can be encoded in a much simpler way. Let us analyze the case g(z) = z d . As in [5], given X = x 1 x 2 . . . x n ∈ ZZ n m , for all i ∈ IIN let S i (X) def = x 1 a i 1 + x 2 a i 2 + . . . + x n a i n be the i-th power sum of X, and S X (z) def = S 1 (X)z + S 2 (X)z 2 + S 3 (X)z 3 + . . . . Also, given p ∈ IIN let X mod p ∈ ZZ n p indicate the vector obtained from X by applying the mod p operation to every component of X. There is a unique way to write X = Q X ·p+X mod p, where Q X ∈ ZZ n (m−1)/p +1 and X mod p ∈ ZZ n p . For example, if X = 3791 ∈ ZZ 4 10 then X mod 5 = 3241 ∈ ZZ 4 5 , Q X = 0110 ∈\nZZ n 2 and X = 3791 = 0110 · 5 + 3241. Given s, p, n ∈ IIN, A ⊆ ZZ n s and B ⊆ ZZ n p , let A · p + B def = {X = Q · p + R : Q ∈ A and R ∈ B}. In general, ZZ n m ⊆ ZZ n (m−1)/p +1 ·p+ZZ n p . However, the equality holds if, and only if, m is a multiple of p. Note also that if m = sp, with s ∈ IIN (as in the above example), then ZZ n m = ZZ n s · p + ZZ n p . We have the following.\nTheorem 4: In the hypothesis of Theorem 3, let K be any ﬁeld with char(K) = p, p odd prime, g(z) = z 2t+1 , with 2t + 1 ≤ p ⇐⇒ t ≤ (p − 1)/2, and σ(z) = 0. Then\n{X ⊆ S + : σ 1 (X) = σ 3 (X) = . . . = σ 2t−1 (X) = 0} = {X ⊆ S + : S 1 (X) = S 3 (X) = . . . = S 2t−1 (X) = 0} =\nSo, C p def = C 0,z 2t+1 ((p − 1)∂S + ) is a p-ary linear code. Also, if m def = sp, with s ∈ IIN∪{+∞}, then 1) the following represen- tation holds for the m-ary code C m def = C 0,z 2t+1 ((m − 1)∂S + ):\n(the above sum and product are those deﬁned in the naturals); 2) the minimum symmetric L 1 distance of C m is d S (C m ) ≥ 2t + 1; and 3) the redundancy is ρ(C m ) = t log m |K|.\nProof: Frobenius automorphism implies, [1 + zq(z)] p = 1+z p [q(z)] p = 1 mod z d , for all q(z) ∈ K[z] and d ≤ p. From this and Theorem 2, if d ≤ p then X ⊆ S + =⇒ X = Q X ·p+ X mod p =⇒ σ X (z) = [σ Q X (z)] p σ X mod p (z) =⇒ σ X (z) = σ X mod p (z) mod z d =⇒ σ od X (z) = σ od X mod p (z) mod z d . This and the deﬁnition of σ od X (z) imply the ﬁrst and second equality in (14). Also, if d ≤ p and X = Q X · p + X mod p ⊆ S + then S X (z) = S Q X ·p+X mod p (z) = pS Q X (z) + S X mod p (z) = S X mod p (z), because p = 0 mod p. This and the deﬁnition of S od X (z) imply the last equality in (14). With regard to the third equality in (14), Newton\u2019s identity (see [2, page 212] and [3, page 301]) implies that for all multisets X ∈ ZZ n m , S X (z)σ X (z) + zσ X (z) = 0; and so,\nFrom these relations and 1, 2, . . . , d − 1 ∈ ZZ p − {0} (be- cause d ≤ p), by induction, it can be easily seen that σ 1 (X) = σ 3 (X) = . . . = σ 2 d/2 −1 (X) = 0 if, and only if, S 1 (X) = S 3 (X) = . . . = S 2 d/2 −1 (X) = 0. Now, these last relations for d = 2t + 1 imply that C p is the null space of the n vectors (a i , a 3 i , . . . , a 2t−1 i ) ∈ K t , i = 1, 2, . . . , n; and so, C p is a subspace of the vector space (ZZ n p , +, ZZ p , ·). With regard to (15), since m = sp, it follows X = Q X · p + X mod p ∈ C m ⇐⇒ X ∈ ZZ n m , Q X ∈ ZZ n s ,\nX mod p ∈ ZZ n p and S od X (z) = S od X mod p (z) = 0 mod z 2t+1 ⇐⇒ X = Q X · p + X mod p ∈ ZZ n s · p + C p . The minimum dis- tance is d S (C m ) ≥ 2t+1 because of Theorem 3. With regard to the redundancy, if we let k be the number of information dig- its/dimension of C p and r be the number of check digits then r = n − k ≤ [K : ZZ p ] · t = t log p |K| because C p is the null space of n vectors in K t (actually, r = t log p |K|). Hence, from (15), log m |C m | = log m (|ZZ n s | · |C p |) = log m s n p k = log m (sp) n /p r = log m m n /p r = n − r log m p. =⇒\nGiven the representation of (15), an efﬁcient encoding function for the code C m can be designed as the encoding function for the asymmetric codes given in Section V of [5]. However, we would like to mention that for certain applications (such as, multilevel ﬂash memory design and EC code deisgn for the repetition channel) it might be more convenient to consider the codes C 0,z 2t+1 (C ∪ D) where ∂S + def = ∂C ∪ ∂D, with ∂C ∩ ∂D = ∅, |∂C| = r , |∂D| = k (= dimension of C p ), C def = (p−1)∂C and D def = (m−1)∂C. In this way, C 0,z 2t+1 (C∪D) is\na subcode of C m and the encoding function to C 0,z 2t+1 (C ∪D) is deﬁned as E(X) def = γ(X) X; where γ(X) ∈ ZZ r p ( ⇐⇒ γ(X) ⊆ C) is the check symbol associated with the data word X ∈ ZZ k m (⇐⇒ X ⊆ D). Note that, even though X ∈ ZZ k m , the check symbol γ(X) can be computed as γ(X mod p) because γ(X) ≡ γ(X mod p), all this for any m ∈ IIN. For example, let K = GF (p = 11), ∂S + = {1, 2, 3, 4, 5}, t = 3, m = 16 (but, any other m ∈ IIN is ﬁne), r = 3, k = 2, ∂C = {1, 2, 3}, ∂D = {4, 5}, C = 10 · {1, 2, 3} and D = 15 · {4, 5}. The H matrix of the code C p = C 0,z 2t+1 ((p − 1)∂S + ) is\n1 2 3 4 5 1 8 5 9 4 1 10 1 1 1\n1 0 0 3 4 0 1 0 8 2\n1 0 0 −8 −7 0 1 0 −3 −9 0 0 1 −5 −1\n \nc 1 = 8x 4 + 7x 5 mod 11, c 2 = 3x 4 + 9x 5 mod 11, c 3 = 5x 4 + x 5 mod 11.\nThis work is supported by the National Science Foundation under Grant CCF-1117215 and by the Italian MIUR Grant PRIN 2009-2009EL7424."},"refs":[{"authors":[{"name":"Y. Cassut"},{"name":"M. Schwart"},{"name":"V. Bohossia"},{"name":"J. Bruc"}],"title":{"text":"Codes for multi- level ﬂash memories: Correcting asymmetric limited-magnitude errors, Proc"}},{"authors":[{"name":"E. R. Berlekam"}],"title":{"text":"Algebraic coding theory, Aegean Park Press, 1984"}},{"authors":[{"name":"R. Rot"}],"title":{"text":"Introduction to Coding Theory, Cambridge University Press, 2006"}},{"authors":[{"name":"L. G. Tallini"},{"name":"B. Bose"}],"title":{"text":"On symmetric/asymmetric Lee distance error control codes and elementary symmetric functions"}},{"authors":[{"name":"L. G. Tallini"},{"name":"B. Bose"}],"title":{"text":"On L 1 -distance error control codes"}},{"authors":[{"name":"L. G. Tallini"},{"name":"B. Bose"}],"title":{"text":"Reed-Muller codes, elementary symmetric functions and asymmetric error correction"}},{"authors":[{"name":"L. G. Tallini"},{"name":"B. Bose"}],"title":{"text":"On decoding some error control codes using the elementary symmetric functions"}},{"authors":[{"name":"L. G. Tallini"},{"name":"N. Elarief"},{"name":"B. Bose"}],"title":{"text":"On Efﬁcient Repetition Error Correcting Codes"}},{"authors":[{"name":"L. G. Tallini"},{"name":"B. Bose"}],"title":{"text":"On a new class of error control codes and symmetric functions"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565709.pdf"},"links":[{"id":"1569565775","weight":18},{"id":"1569558859","weight":18},{"id":"1569564857","weight":9},{"id":"1569566275","weight":9},{"id":"1569560503","weight":9},{"id":"1569565729","weight":100},{"id":"1569566635","weight":9}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S5.T5.1","endtime":"10:10","authors":"Luca G. Tallini, Bella Bose","date":"1341309000000","papertitle":"On Symmetric L1 distance error control codes and elementary symmetric functions","starttime":"09:50","session":"S5.T5: Coding for L1 Distance and Asymmetric Errors","room":"Kresge Little Theatre (035)","paperid":"1569565709"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
