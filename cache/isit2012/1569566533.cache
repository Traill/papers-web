{"id":"1569566533","paper":{"title":{"text":"Enhancing the Error Correction of Finite Alphabet Iterative Decoders via Adaptive Decimation"},"authors":[{"name":"Shiva Kumar Planjery"},{"name":"Bane Vasi´c"},{"name":"David Declercq"}],"abstr":{"text":"Abstract\u2014Finite alphabet iterative decoders (FAIDs) for LDPC codes were recently shown to be capable of surpassing the Belief Propagation (BP) decoder in the error ﬂoor region on the Binary Symmetric channel (BSC). More recently, the technique of decimation which involves ﬁxing the values of certain bits during decoding, was proposed for FAIDs in order to make them more amenable to analysis while maintaining their good performance. In this paper, we show how decimation can be used adaptively to further enhance the guaranteed error correction capability of FAIDs that are already good on a given code. The new adaptive decimation scheme proposed has marginally added complexity but can signiﬁcantly improve the slope of the error ﬂoor performance of a particular FAID. We describe the adaptive decimation scheme particularly for 7-level FAIDs which propagate only 3-bit messages and provide numerical results for column-weight three codes. Analysis suggests that the failures of the new decoders are linked to stopping sets of the code."},"body":{"text":"The error ﬂoor problem of low-density parity-check (LDPC) codes under iterative decoding is now a well-known problem, where the codes suffer from an abrupt degradation in their error-rate performance in spite of having good minimum distance. The problem has been attributed to the presence of harmful conﬁgurations generically termed as trapping sets [1] present in the Tanner graph, which cause the iterative decoder to fail for some low-noise conﬁgurations, thereby reducing its guaranteed error correction capability to an extent that is far from the limits of maximum likelihood decoding. More importantly for the BSC, the slope of the error ﬂoor is governed by the guaranteed correction capability [2].\nRecently, a new class of ﬁnite alphabet iterative decoders (FAIDs) that have a much lower complexity than the BP decoder, were proposed for LDPC codes on the BSC [3] [4] and were shown to be capable of outperforming BP in the error ﬂoor. Numerical results on several column-weight three codes showed that there exist 7-level FAIDs requiring only 3 bits of precision that can achieve a better guaranteed error correction ability than BP, thereby surpassing it in the error ﬂoor region. However, analyzing these decoders for providing performance guarantees proved to be difﬁcult.\nMore recently, decimation-enhanced FAIDs [5] were pro- posed for BSC in order to make FAIDs more amenable to anal- ysis while maintaining their good performance. The technique of decimation involves guessing the values of certain bits, and\nﬁxing them to these values while continuing to estimate the remaining bits (see [5] for references). In [5], the decimation was carried out by the FAID based on messages passed for some iterations, and a decimation scheme was provided such that a 7-level DFAID matched the good performance of the original 7-level FAID while being analyzable at the same time.\nIn this paper, we show how decimation can be used adaptively to further increase the guaranteed error correction capability of FAIDs. The adaptive scheme has only marginally increased complexity, but can signiﬁcantly improve the error- rate performance compared to the FAIDs. We speciﬁcally focus on decoders that propagate only 3-bit messages and column-weight three codes since these enable simple imple- mentations and thus have high practical value. We also provide some analysis of the decoders which suggests that the failures are linked to stopping sets of the code. Numerical results are also provided to validate the efﬁcacy of the proposed scheme.\nLet G = (V ∪ C, E) denote the Tanner graph of an (n,k) binary LDPC code C with the set of variable nodes V = {v 1 , · · · , v n } and set of check nodes C = {c 1 , · · · , c m }. E is the set of edges in G. A code C is said to be d v -left-regular if all variable nodes in V of graph G have the same degree d v . The degree of a node is the number of its neighbors. d min is the minimum distance of the code C.\nA trapping set is a non-empty set of variable nodes in G that are not eventually corrected by the decoder [1].\nA multilevel FAID F is a 4-tuple given by F = (M, Y, Φ v , Φ c ) [4]. The messages are levels conﬁned to an alphabet M of size 2s+1 deﬁned as M = {0, ±L i : 1 ≤ i ≤ s}, where L i ∈ R + and L i > L j for any i > j. Y denotes the set of possible channel values that are input to the decoder. For the case of BSC as Y = {±C : C ∈ R + }, and for each variable node v i ∈ V , the channel value y i ∈ Y is determined by y i = (−1) r i C, where r i is received from the BSC at v i .\nLet m 1 , · · · , m u denote the incoming messages to a node. The update function Φ c : M d c −1 → M is used at a check node with degree d c , and is deﬁned as\nThe update function Φ v : Y ×M d v −1 → M is a symmetric rule used at a variable node with degree d v and is deﬁned as\nThe function Q is deﬁned based on a threshold set T = {T i : 1 ≤ i ≤ s + 1} where T i ∈ R + and T i > T j if i > j, and T s+1 = ∞, such that Q(x) = sgn(x)L i if T i ≤ |x| < T i+1 , and Q(x) = 0 otherwise. The weight ω i is computed at node v i using a symmetric function Ω : M d v −1 → {0, 1}. Based on this, Φ v can be described as a linear-threshold (LT) or non- linear threshold (NLT) function. If Ω = 1 (or constant), then it is an LT function, else it is an NLT function. Φ v can also be described as a look-up table (LUT) as shown in Table I (for y i = −C, it can be obtained from symmetry). This rule is an NLT rule and will be one of the rules used in the proposed decimation scheme.\nLet T k i (G) denote the computation tree of graph G cor- responding to a decoder F enumerated for k iterations with variable node v i ∈ V as its root. A node w ∈ T k i (G) is a descendant of a node u ∈ T k i (G) if there exists a path starting from node w to the root v i that traverses through node u.\nDeﬁnition 1 (Isolation assumption): Let H be a subgraph of G induced by P ⊆ V with check node set W ⊆ C. The computation tree T k i (G) with the root v i ∈ P is said to be isolated if and only if for any node u / ∈ P ∪ W in T k i (G), u does not have any descendant belonging to P ∪ W . If T k i (G) is isolated ∀ v i ∈ P , then the subgraph H is said to satisfy the isolation assumption in G for k iterations.\nRemark: The above deﬁnition is a revised version of the one given in [3].\nThe critical number of a FAID F on a subgraph H is the smallest number of errors for which F fails on H under the isolation assumption.\nLet N (u) denote the set of neighbors of a node u in the graph G and let N (U ) denote the set of neighbors of all u ∈ U . Let m k (v i , N (v i )) denote the set of outgoing messages from v i to all its neighbors in the k th iteration. Let b k i denote the bit associated to a variable node v i ∈ V that is decided by the iterative decoder at the end of the k th iteration.\nWe will ﬁrst provide some deﬁnitions and notations related to the concept of decimation and discuss its incorporation into\nthe framework of FAIDs before we delve into the details of adaptive decimation.\nDeﬁnition 2: A variable node v i is said to be decimated at the end of l th iteration if b k i is set to b ∗ i ∀k ≥ l. Also, m k (v i , N (v i )) = {(−1) b ∗ i L s }, ∀k ≥ l irrespective of its incoming messages, i.e., v i always sends the strongest possible messages.\nRemark: If a node v i is decimated, then all its descendants in the computation tree T k i (G) can be deleted since the node always sends (−1) b ∗ i L s to its parent.\nA decimation rule β : Y × M d v → {−1, 0, 1} is a function used by the decoder to decide whether a variable node should be decimated and what value it should be decimated to. Let γ i denote the output of a decimation rule applied to a node v i . If γ i = 0, then the node is not decimated. If γ i = 1, then b ∗ i = 0, and if γ i = −1, then b ∗ i = 1\nRemark: The decimation rule is a function of the channel value and the most recent incoming messages received by the variable node before the decimation rule is applied.\nWe shall refer to each instance of applying a decimation rule on all the variable nodes as a decimation round.\nThere are two key aspects to note regarding the application of a decimation rule: 1) the decimation rule is applied after messages are passed iteratively for some l iterations, and 2) after each instance of applying the decimation rule, all messages are cleared to zero (which is practically restarting the decoder except that the decimated nodes remain decimated).\nLet N d denote the number of decimation rounds carried out by the decoder with a given decimation rule β beyond which no more variable nodes are decimated.\nDeﬁnition 3: The residual graph G is the induced sub- graph of the set of variable nodes in G that are not decimated after N d decimation rounds.\nWe can now formally deﬁne the class of adaptive decimation-enhanced multilevel FAIDs (ADFAIDs) as follows. A decoder belonging to such a class denoted by F A is deﬁned as F A = (M, Y, Φ D v , Φ d v , Φ r v , B, Φ c ), where the sets M and Y, and the map Φ c are same as the ones deﬁned for a multi- level FAID. The map Φ D v : Y × M d v −1 × {−1, 0, 1} → M is the update rule used at the variable node. It requires the output of a decimation rule β as an one of its arguments and also uses the maps Φ d v : Y × M d v −1 → M and Φ r v : Y × M d v −1 → M to compute its output. For simplicity, we deﬁne it for the case of d v = 3 as follows.\nΦ d v (y i , m 1 , m 2 ), if γ i = 0, p ≤ N d Φ r v (y i , m 1 , m 2 ), if γ i = 0, p > N d γ i L s , \t if γ i = ±1\nwhere p denotes the p th decimation round completed by the decoder. The maps Φ d v and Φ r v are deﬁned as either LT or NLT functions or as look-up tables similar to Φ v of a FAID F .\nRemark: The new class of decoders proposed in this paper use two different maps, Φ d v and Φ r v , for updating the messages on non-decimated variable nodes. Φ d v is the map used to update messages speciﬁcally during the decimation procedure,\nwhereas Φ r v is the map used to decode the remaining non- decimated nodes after the decimation procedure is completed. Also note that for the case of |M| = 7, we restrict the deﬁni- tion of Φ d v to satisfy Φ d v (C, 0, 0) = L 1 , Φ d v (C, L 1 , L 1 ) = L 2 , and Φ d v (C, L 2 , L 2 ) = L 3 . Φ r v is also deﬁned similarly.\nProposition 1: Given a decimation rule β, if the number of decimated nodes after the p th decimation round is the same as the number of decimated nodes after the (p − 1) th decimation round, then no additional nodes will get decimated in the subsequent decimation rounds.\nRemark: This would be the stopping criterion used for the decimation procedure. In the above case, N d = p.\nThe set B is the set of decimation rules used for adaptive decimation and for any β ∈ B, it satisﬁes the following properties (speciﬁed for d v = 3).\n1) β(C, m 1 , m 2 , m 3 ) = −β(−C, −m 1 , −m 2 , −m 3 ) ∀m 1 , m 2 , m 3 ∈ M\n2) β(C, m 1 , m 2 , m 3 ) = −1 and β(−C, m 1 , m 2 , m 3 ) = 1 ∀m 1 , m 2 , m 3 ∈ M\n3) Given m 1 , m 2 , m 3 ∈ M, if β(C, m 1 , m 2 , m 3 ) = 1, then β(C, m 1 , m 2 , m 3 ) = 1 ∀m 1 , m 2 , m 3 ∈ M such that m 1 ≥ m 1 , m 2 ≥ m 2 , and m 3 ≥ m 3 .\nRemark: Property 2 implies that a node v i can be decimated to zero only if y i = C and to one only if y i = −C. Consequently a node initially correct will never be decimated to a wrong value and a node initially wrong will never be decimated to the correct value. Then, a necessary condition for successful decoding is that no node initially in error is decimated. We shall now restrict our discussion to d v = 3 for the remainder of the paper.\nFor a given decimation rule β, a set Ξ can be used to com- pletely specify β, where Ξ is deﬁned as the set of all unordered triples (m 1 , m 2 , m 3 ) ∈ M 3 such that β(C, m 1 , m 2 , m 3 ) = 1. Note that for any unordered triple (m 1 , m 2 , m 3 ) ∈ Ξ, β(−C, −m 1 , −m 2 , −m 3 ) = −1 by property 1, so Ξ is sufﬁcient to completely specify β. A β is considered to be a conservative decimation rule if | Ξ| is small and an aggressive rule if | Ξ| is large.\nNote that the class of decimation-enhanced FAIDs deﬁned in our previous work [5] is a special case of the newly proposed decoders where Φ d v = Φ r v and B = {β}. In other words, only a single non-adaptive decimation rule and a single map is used for updating messages in the DFAIDs of [5].\nFor the remainder of the paper, we shall refer to variable nodes that are initially in error in G as error nodes and variable nodes that are initially correct as correct nodes.\n), the primary role of decimation is to isolate the subgraph associated with the error pattern from the rest of the graph by decimating as many correct nodes outside this subgraph as possible. The rationale behind resetting the messages to zero at the end of each decimation round is to allow more non-decimated correct nodes that are close to the neighborhood of the decimated correct nodes to possibly\nbe decimated as long as none of the error nodes have been decimated. This is possible since the decimated nodes always send the strongest message (± L s ).\nNow if a given error pattern is such that the error nodes are relatively clustered with many interconnections between them through their neighboring check nodes, then a more conservative β would have to be used by the decoder to ensure that none of the error nodes are decimated. However, if the error pattern is such that the error nodes are more spread out, then it may be desirable to use a more aggressive β as there will be many correct nodes in the neighborhood of the error nodes that can be decimated without decimating the error nodes, and, in turn, possibly help the decoder to converge. This is our main motivation for the use of adaptive decimation in the newly proposed decoders, and we will eventually show that adaptive decimation can help achieve an increase in the guaranteed error correction capability of the code.\nWe will now describe a particular adaptive decimation scheme used by the decoder F A in order to enhance the guaranteed error correction capability. In the proposed scheme, the set B consists of two decimation rules, namely B = {β (1) , β (2) }, where Ξ (1) and Ξ (2) are the sets of unordered triples that completely specify the rules β (1) and β (2) respec- tively. The rule β (1) is used only once at the end of the third iteration, and then from that point, β (2) is used after every two iterations ( l = 2). The use of adaptive decimation is carried out only through β (2) as follows.\nWe deﬁne a sequence of decimation rules { β (2)[j] } j from β (2) by considering ordered subsets of Ξ (2) with increasing size. Let N β be the number of rules in the sequence { β (2)[j] } j and let Ξ (2)[j] denote the set that speciﬁes the rule β (2)[j] . Then Ξ (2)[j] is deﬁned for each β (2)[j] in a way such that Ξ (2)[j] ⊂ Ξ (2)[j+1] ∀i ∈ {1, . . . , N β −1} with Ξ (2)[N β ] = Ξ (2) . This implies that the sequence of rules are such that β (2)[j+1] is less conservative than β (2)[j] , with β (2)[1] being the most conservative and β (2)[N β ] = β (2) being least conservative (or most aggressive). Note that each subset Ξ (2)[j] must be chosen in a manner that ensures that its corresponding rule β (2)[j] satisﬁes the properties of β mentioned previously.\nFor a given error pattern, the decoder starts the decimation procedure by passing messages using the map Φ d v and applying the decimation rule β (1) at the end of the third iteration after which the messages are reset to zero. Then the most conservative rule in the sequence { β (2)[j] } j , which is β (2)[1] , is used after every two iterations (followed by resetting the messages) until no more nodes can be decimated. The map Φ r v then is used to decode the remaining non-decimated nodes. If the decoder still does not converge, then the whole decoding process is repeated by using a more aggressive rule β (2)[2] in place of β (2)[1] . This decoding process continues until the decoder converges or until all rules in the sequence { β (2)[j] } j have been used. Let N b denote the number of decimated bits at the end of a decimation round. The decoding scheme can\nbe summarized as follows. Note that this scheme is devised particularly for the case of |M| = 7.\nAlgorithm 1 Adaptive decimation-enhanced FAID algorithm 1) Set j = 1. Note that Φ c will always be used to update\nmessages at the check node. 2) Initialize γ i = 0 ∀v i ∈ V .\n3) Start the decimation procedure by passing messages for three iterations using Φ d v . If the decoder converges within those three iterations, STOP.\n4) Apply decimation rule β (1) for every v i ∈ V . Then reset all messages to zero and set q = 0.\n5) Pass messages for two iterations using Φ d v for update at the non-decimated nodes. If the decoder converges within those two iterations, STOP.\n6) Apply decimation rule β (2)[j] only on nodes v i for which γ i = 0. Then reset all messages to zero. If N b > q, q = N b and go back to step 5, else go to step 7.\n8) If decoder converges or has reached maximum allowed iterations, STOP. Else j = j + 1.\nRemarks: 1) The only criterion used by the decoder to decide when to use a more aggressive rule β (2)[j] on a given error pattern is whether the decoding has failed. 2) The reason for applying β (1) at the end of third iteration is that at least three iterations are required for a ± L 3 to be passed. 3)The reason for the choice of every 2 iterations for applying β (2)[j] is because 2 iterations is small enough to help prevent the growth of wrong message strengths but sufﬁcient to allow all levels in M to be passed.\nFor the proposed decoders, the map Φ r v is simply chosen to be the Φ v of a particular FAID already known to be good on a given code, and for which we want to improve the guaranteed error correction capability. For the numerical results, Φ r v is chosen to be the Φ v of a 7-level FAID deﬁned by Table I.\nThe choice of Φ d v on the other hand is non-trivial. It is designed based on analyzing messages that are passed within dense subgraphs that could potentially be trapping sets for a given FAID when errors are introduced in them under the isolation assumption. The rule is chosen under the premise that the growth of message strengths within the subgraph should be slow since many correct nodes in the subgraph would most likely be connected to error nodes, and multiple error nodes may be interconnected to each other in the subgraph (if the number of errors introduced is comparable to the size of the subgraph). Explicit design methods for Φ d v are not discussed in this paper, but we provide a particular Φ d v that was designed based on the above philosophy and used for the numerical results. It is an LT rule (see Section II), so it can be described by assigning values to elements in M, T , and Y. The map is deﬁned with the following assignments; L 1 = 1.1, L 2 = 2.3,\nL 3 = 6.6, T 1 = 0.8, T 2 = 2.8, T 3 = 4, C = 1.5. This was found to be a good rule for decimation.\nDue to page constraints, no proofs are provided (but they will be provided in the journal version of this paper). For the analysis, we assume that the all-zero codeword is transmitted which is valid since the decoders considered are symmetric.\nProposition 2: A node v i can receive a ± L 3 from its neighbor c j in the ﬁrst or second iteration after resetting the messages, only if all nodes in N (c j )\\v i have been decimated.\nLemma 1: If β (2)[j] (C, L 3 , −L 2 , −L 2 ) = 1 and if ∀c k ∈ N (v i ) all error nodes in N (c k )\\v i are non-decimated, then a correct node v i will be decimated if it receives an L 3 during a decimation round.\nRemark: Note that β (2)[j] will always be deﬁned so that β (2)[j] (C, L 3 , −L 2 , −L 2 ) = 1 for any j as explained in the next subsection. Also note how resetting messages at the end of each decimation round can help with decimating more correct nodes due to the above lemma.\nTheorem 1: If β (2)[j] (C, L 3 , −L 2 , −L 2 ) = 1 and no error node is decimated, then any correct node in the residual graph G is connected to check nodes that have at least degree-two.\nCorollary 1: If Theorem 1 holds and no error node in the residual graph G is connected to a degree-one check node, then G is a stopping set.\nRemark: Note that if an error node in the residual graph G is connected to a degree-one check node, it would receive L 3 in every iteration for the remainder of the decoding (again assuming no error nodes are decimated), and this will most likely lead to a decoder convergence. Therefore, if no error node is decimated, the decoder is more likely to fail when the residual graph G is a stopping set (refer to [1] for details).\nThe above remark is an important observation since we can now design the rules β (1) and the sequence { β (2)[j] } j based on analyzing error patterns whose errors are entirely contained in the minimal stopping sets of a given code. For instance, if our goal is to correct up to t-errors, then we consider all error patterns up to a weight t in the stopping sets in order to design\nIf FAID F with Φ v = Φ r v has a critical number of t+1 on a stopping set whose induced subgraph is H, then F A is guaranteed to correct up to t errors introduced in H on the code if the residual graph is H. In other words, on a particular code, Φ r v is more likely to correct all error patterns up to weight- t whose support lies in a stopping set in the code, if it has a critical number of t + 1 on the stopping set.\nThe design of β (1) involves selecting the triples that should be included in Ξ (1) , which depends on the number of errors we are trying to correct and the type of harmful subgraphs present in G. β (1) should be chosen to be conservative enough so that no error nodes are decimated. On the other hand, the design of β (2) not only involves selecting the triples that should be included in Ξ (2) , but also determining a speciﬁc\nordering on the triples that will be included in subsets Ξ (2)[j] which determine the sequence of rules { β (2)[j] } j used starting from the least conservative rule, and this is dependent on the structure of the code. Both rules can be designed by analyzing them on errors introduced in stopping sets of the code.\nIn order to specify the set Ξ (1) , we just specify the message triples with the weakest values. For specifying Ξ (2) in a concise way, we shall introduce some notations. Let Ξ (2) be divided into two disjoint subsets, i.e., Ξ (2) = Λ∪Γ, where Λ is a subset that contains all triples (L 3 , m 2 , m 3 ) ∈ M 3 such that m 2 , m 3 ≥ −L 2 . Based on the analysis described previously, any Ξ (2)[j] deﬁned should always have Λ as its subset, regardless of the code. The subset Γ, which is dependent on the code, is an ordered set whose ordering determines the subsets used to specify the sequence of rules { β (2)[j] } j .\nNumerical results are provided in Fig. 1 and Fig. 2 for two codes: the well-known (155, 64) Tanner code and a structured rate 0.753 (732, 551) code constructed based on latin squares [6] with d min = 12. For the Tanner code, the set Ξ (1) contains all triples (m 1 , m 2 , m 3 ) ∈ M 3 such that (m 1 , m 2 , m 3 ) ≥ (L 3 , 0, 0) and (m 1 , m 2 , m 3 ) ≥ (L 2 , L 2 , L 1 ) (comparison is componentwise). For the high-rate structured code, Ξ (1) contains all triples such that (m 1 , m 2 , m 3 ) ≥ (L 3 , L 1 , −L 3 ), (m 1 , m 2 , m 3 ) ≥ (L 3 , −L 1 , −L 1 ), and (m 1 , m 2 , m 3 ) ≥ (L 2 , L 1 , L 1 ). |Ξ (1) | = 12 for the Tanner code and |Ξ (1) | = 24 for the (732, 551) code. The Γ sets in Ξ (2) = Λ ∪ Γ for the structured code and the Tanner code are shown in Tables II and III respectively. The cardinalities of the subsets of Ξ (2) used by each of the two codes are {|Ξ (2)[j] |} j = {24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35} and {| Ξ (2)[j] |} j = {23, 25, 26, 27, 29} respectively. The max- imum number of iterations allowed for BP and 7-level FAID, and for Φ r v of the 7-level ADFAID, was 100.\nThe signiﬁcant improvement in the slope of the error ﬂoor by using the 7-level ADFAID is evident. For the Tanner code, it was veriﬁed that all 6-error patterns are corrected by the 7-level ADFAID while the 7-level FAID corrects all 5-errors and BP fails on 5-errors. For the high-rate structured code, no failed 5-error patterns were found in the region of\nsimulation shown in Fig. 2, which is signiﬁcant since the code has d min = 12. This shows that for certain high-rate codes whose graphs are relatively dense and for which it becomes difﬁcult to ensure high d min in the code, the FAIDs with adaptive decimation can possibly come close to achieving the guaranteed error correction of maximum likelihood decoding. Note that the 7-level ADFAIDs are still 3-bit message passing decoders which have reasonable complexity, and that is still lower than BP.\nThis work was funded by NSF grants CCF-0830245 and CCF-0963726, and by Institut Universitaire de France grant."},"refs":[{"authors":[{"name":"T. Richardson"}],"title":{"text":"Error ﬂoors of LDPC codes"}},{"authors":[{"name":"M. Ivkovic"},{"name":"S. K. Chilappagari"},{"name":"B. Vasic"}],"title":{"text":"Eliminating trapping sets in low-density parity-check codes by using Tanner graph covers"}},{"authors":[{"name":"S. K. Planjery"},{"name":"D. Declercq"},{"name":"S. K. Chilappagari"},{"name":"B. Vasic"}],"title":{"text":"Multilevel de- coders surpassing belief propagation on the binary symmetric channel"}},{"authors":[{"name":"S. K. Planjery"},{"name":"D. Declercq"},{"name":"L. Danjean"},{"name":"B. Vasic"}],"title":{"text":"Finite alphabet iterative decoders for LDPC codes surpassing ﬂoating-point iterative decoders"}},{"authors":[{"name":"S. K. Planjery"},{"name":"B. Vasic"},{"name":"D. Declercq"}],"title":{"text":"Decimation-enhanced ﬁnite alphabet iterative decoders for LDPC codes on the BSC"}},{"authors":[{"name":"D. V. Nguyen"},{"name":"B. Vasic"},{"name":"M. Marcellin"},{"name":"S. K. Chilappagari"}],"title":{"text":"On the construction of structured LDPC codes free of small trapping sets"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566533.pdf"},"links":[{"id":"1569566567","weight":3},{"id":"1569564843","weight":4},{"id":"1569566527","weight":2},{"id":"1569566485","weight":2},{"id":"1569565883","weight":11},{"id":"1569564889","weight":3},{"id":"1569566725","weight":3},{"id":"1569565377","weight":2},{"id":"1569566385","weight":2},{"id":"1569564635","weight":2},{"id":"1569566799","weight":2},{"id":"1569565067","weight":2},{"id":"1569559665","weight":2},{"id":"1569561021","weight":2},{"id":"1569564669","weight":8},{"id":"1569566815","weight":2},{"id":"1569566875","weight":3},{"id":"1569564605","weight":5},{"id":"1569559617","weight":2},{"id":"1569566981","weight":2},{"id":"1569566605","weight":7},{"id":"1569566683","weight":3},{"id":"1569566855","weight":6},{"id":"1569566869","weight":3},{"id":"1569565097","weight":2},{"id":"1569566227","weight":5},{"id":"1569566091","weight":3},{"id":"1569559259","weight":4},{"id":"1569566697","weight":4},{"id":"1569566597","weight":2},{"id":"1569565551","weight":5},{"id":"1569565711","weight":4},{"id":"1569566761","weight":6},{"id":"1569566943","weight":3},{"id":"1569565091","weight":9},{"id":"1569566591","weight":3},{"id":"1569566571","weight":3},{"id":"1569552245","weight":2},{"id":"1569565607","weight":3},{"id":"1569567045","weight":3},{"id":"1569565227","weight":2},{"id":"1569564481","weight":3},{"id":"1569560833","weight":4},{"id":"1569566415","weight":5},{"id":"1569564805","weight":7},{"id":"1569567005","weight":3},{"id":"1569566081","weight":10},{"id":"1569565355","weight":2},{"id":"1569564469","weight":2},{"id":"1569565931","weight":4},{"id":"1569566373","weight":4},{"id":"1569566647","weight":2},{"id":"1569551535","weight":3},{"id":"1569564897","weight":2},{"id":"1569565775","weight":4},{"id":"1569566871","weight":5},{"id":"1569565461","weight":4},{"id":"1569565171","weight":3},{"id":"1569566207","weight":4},{"id":"1569564227","weight":2},{"id":"1569558325","weight":4},{"id":"1569565837","weight":2},{"id":"1569566671","weight":2},{"id":"1569566303","weight":2},{"id":"1569564233","weight":3},{"id":"1569566459","weight":5},{"id":"1569563411","weight":2},{"id":"1569560427","weight":2},{"id":"1569564849","weight":4},{"id":"1569559541","weight":4},{"id":"1569565123","weight":2},{"id":"1569566941","weight":3},{"id":"1569566033","weight":2},{"id":"1569565609","weight":4},{"id":"1569565291","weight":3},{"id":"1569564203","weight":8},{"id":"1569566821","weight":2},{"id":"1569556713","weight":4},{"id":"1569562685","weight":2},{"id":"1569566467","weight":2},{"id":"1569566157","weight":2},{"id":"1569566903","weight":2},{"id":"1569565859","weight":3},{"id":"1569565809","weight":7},{"id":"1569566843","weight":2},{"id":"1569558483","weight":2},{"id":"1569566563","weight":8},{"id":"1569566173","weight":3},{"id":"1569559221","weight":2},{"id":"1569565347","weight":3},{"id":"1569566925","weight":3},{"id":"1569564387","weight":4},{"id":"1569565455","weight":2},{"id":"1569566497","weight":20},{"id":"1569566795","weight":6},{"id":"1569566963","weight":2},{"id":"1569561679","weight":4},{"id":"1569566709","weight":3},{"id":"1569564989","weight":2},{"id":"1569566717","weight":2},{"id":"1569566015","weight":6},{"id":"1569565897","weight":2},{"id":"1569551763","weight":3},{"id":"1569565953","weight":6},{"id":"1569566895","weight":7},{"id":"1569566749","weight":2},{"id":"1569566269","weight":4},{"id":"1569564189","weight":4},{"id":"1569564195","weight":2},{"id":"1569561513","weight":3},{"id":"1569566985","weight":2},{"id":"1569564613","weight":6},{"id":"1569567009","weight":8},{"id":"1569566865","weight":3},{"id":"1569565321","weight":7},{"id":"1569558785","weight":4},{"id":"1569566193","weight":3},{"id":"1569565907","weight":2},{"id":"1569566343","weight":4},{"id":"1569564311","weight":3},{"id":"1569565803","weight":6},{"id":"1569565785","weight":3},{"id":"1569566239","weight":2},{"id":"1569566679","weight":7},{"id":"1569565989","weight":5},{"id":"1569566575","weight":4},{"id":"1569563981","weight":5},{"id":"1569561085","weight":2},{"id":"1569566617","weight":5},{"id":"1569559565","weight":3},{"id":"1569566905","weight":4},{"id":"1569566311","weight":4},{"id":"1569563307","weight":4},{"id":"1569566063","weight":6},{"id":"1569555999","weight":5},{"id":"1569566759","weight":2},{"id":"1569559195","weight":5},{"id":"1569566149","weight":2},{"id":"1569566657","weight":5},{"id":"1569558859","weight":7},{"id":"1569565199","weight":15},{"id":"1569565365","weight":4},{"id":"1569566643","weight":3},{"id":"1569566511","weight":2},{"id":"1569566719","weight":2},{"id":"1569566369","weight":2},{"id":"1569566531","weight":6},{"id":"1569567665","weight":5},{"id":"1569561143","weight":3},{"id":"1569566581","weight":2},{"id":"1569565833","weight":6},{"id":"1569564611","weight":2},{"id":"1569565535","weight":5},{"id":"1569562867","weight":10},{"id":"1569566395","weight":2},{"id":"1569566325","weight":13},{"id":"1569566423","weight":2},{"id":"1569564795","weight":5},{"id":"1569567015","weight":3},{"id":"1569559805","weight":10},{"id":"1569566437","weight":2},{"id":"1569566811","weight":2},{"id":"1569565735","weight":26},{"id":"1569559111","weight":8},{"id":"1569553537","weight":3},{"id":"1569565427","weight":3},{"id":"1569566403","weight":2},{"id":"1569565915","weight":2},{"id":"1569552251","weight":3},{"id":"1569553519","weight":2},{"id":"1569567051","weight":2},{"id":"1569566885","weight":2},{"id":"1569564441","weight":6},{"id":"1569566231","weight":4},{"id":"1569566425","weight":2},{"id":"1569554881","weight":3},{"id":"1569554971","weight":3},{"id":"1569565501","weight":3},{"id":"1569566899","weight":2},{"id":"1569566445","weight":3},{"id":"1569566209","weight":3},{"id":"1569566649","weight":2},{"id":"1569565559","weight":2},{"id":"1569566371","weight":2},{"id":"1569565655","weight":4},{"id":"1569566909","weight":2},{"id":"1569566127","weight":2},{"id":"1569565151","weight":6},{"id":"1569558985","weight":2},{"id":"1569563763","weight":4},{"id":"1569566473","weight":11},{"id":"1569564857","weight":9},{"id":"1569564333","weight":2},{"id":"1569566913","weight":4},{"id":"1569566809","weight":13},{"id":"1569566629","weight":2},{"id":"1569566257","weight":8},{"id":"1569565033","weight":5},{"id":"1569566447","weight":2},{"id":"1569565817","weight":2},{"id":"1569565847","weight":7},{"id":"1569564353","weight":3},{"id":"1569563897","weight":2},{"id":"1569557083","weight":2},{"id":"1569565887","weight":2},{"id":"1569565929","weight":2},{"id":"1569566141","weight":3},{"id":"1569563231","weight":21},{"id":"1569565633","weight":3},{"id":"1569566661","weight":2},{"id":"1569565279","weight":2},{"id":"1569555879","weight":5},{"id":"1569566115","weight":5},{"id":"1569565219","weight":2},{"id":"1569558509","weight":2},{"id":"1569565595","weight":22},{"id":"1569565185","weight":6},{"id":"1569566773","weight":7},{"id":"1569566223","weight":8},{"id":"1569558401","weight":2},{"id":"1569566553","weight":9},{"id":"1569564969","weight":5},{"id":"1569565029","weight":9},{"id":"1569566505","weight":9},{"id":"1569565933","weight":3},{"id":"1569562207","weight":5},{"id":"1569565705","weight":2},{"id":"1569566191","weight":2},{"id":"1569567033","weight":4},{"id":"1569565527","weight":6},{"id":"1569566853","weight":5},{"id":"1569566603","weight":2},{"id":"1569566159","weight":4},{"id":"1569566695","weight":3},{"id":"1569566051","weight":8},{"id":"1569561379","weight":2},{"id":"1569565909","weight":2},{"id":"1569561123","weight":5},{"id":"1569567235","weight":2},{"id":"1569565441","weight":2},{"id":"1569565739","weight":5},{"id":"1569565311","weight":2},{"id":"1569566667","weight":2},{"id":"1569566893","weight":5},{"id":"1569566317","weight":9},{"id":"1569560997","weight":3},{"id":"1569563845","weight":4},{"id":"1569560349","weight":3},{"id":"1569566501","weight":4},{"id":"1569565741","weight":4},{"id":"1569566275","weight":4},{"id":"1569566481","weight":11},{"id":"1569565545","weight":3},{"id":"1569566857","weight":5},{"id":"1569565961","weight":2},{"id":"1569566245","weight":5},{"id":"1569560503","weight":3},{"id":"1569565463","weight":2},{"id":"1569566219","weight":2},{"id":"1569566229","weight":3},{"id":"1569565415","weight":2},{"id":"1569561623","weight":2},{"id":"1569564485","weight":11},{"id":"1569566631","weight":4},{"id":"1569565571","weight":2},{"id":"1569565885","weight":2},{"id":"1569566177","weight":5},{"id":"1569565493","weight":8},{"id":"1569557633","weight":2},{"id":"1569564411","weight":2},{"id":"1569566805","weight":8},{"id":"1569559199","weight":3},{"id":"1569566293","weight":2},{"id":"1569565665","weight":3},{"id":"1569566831","weight":6},{"id":"1569565549","weight":6},{"id":"1569565523","weight":2},{"id":"1569565611","weight":2},{"id":"1569557715","weight":6},{"id":"1569564175","weight":2},{"id":"1569566983","weight":5},{"id":"1569566097","weight":3},{"id":"1569566479","weight":12},{"id":"1569566431","weight":2},{"id":"1569566873","weight":2},{"id":"1569565765","weight":9},{"id":"1569565925","weight":2},{"id":"1569565435","weight":2},{"id":"1569557275","weight":2},{"id":"1569565263","weight":3},{"id":"1569565215","weight":2},{"id":"1569565093","weight":5},{"id":"1569565385","weight":5},{"id":"1569565575","weight":3},{"id":"1569565919","weight":6},{"id":"1569565181","weight":2},{"id":"1569566711","weight":4},{"id":"1569565241","weight":2},{"id":"1569566927","weight":11},{"id":"1569565661","weight":6},{"id":"1569565865","weight":2},{"id":"1569566887","weight":6},{"id":"1569565273","weight":2},{"id":"1569564131","weight":2},{"id":"1569552037","weight":2},{"id":"1569564919","weight":4},{"id":"1569565511","weight":3},{"id":"1569566737","weight":4},{"id":"1569566429","weight":2},{"id":"1569566917","weight":14},{"id":"1569566035","weight":4},{"id":"1569566253","weight":2},{"id":"1569565353","weight":14},{"id":"1569564683","weight":3},{"id":"1569564305","weight":4},{"id":"1569564283","weight":2},{"id":"1569564291","weight":2},{"id":"1569566691","weight":3},{"id":"1569565421","weight":2},{"id":"1569566547","weight":3},{"id":"1569566651","weight":2},{"id":"1569565177","weight":4},{"id":"1569566823","weight":3},{"id":"1569566595","weight":2},{"id":"1569566677","weight":2},{"id":"1569565349","weight":8},{"id":"1569566137","weight":6},{"id":"1569565829","weight":2},{"id":"1569566283","weight":4},{"id":"1569566529","weight":8},{"id":"1569565375","weight":2},{"id":"1569566715","weight":3},{"id":"1569565237","weight":8},{"id":"1569566639","weight":4},{"id":"1569566819","weight":5},{"id":"1569565041","weight":2},{"id":"1569566713","weight":2},{"id":"1569565541","weight":5},{"id":"1569566813","weight":3},{"id":"1569566771","weight":2},{"id":"1569564201","weight":2},{"id":"1569562277","weight":4},{"id":"1569566641","weight":2},{"id":"1569565425","weight":2},{"id":"1569564247","weight":2},{"id":"1569564437","weight":3},{"id":"1569563975","weight":2},{"id":"1569551905","weight":2},{"id":"1569564861","weight":9},{"id":"1569564787","weight":3},{"id":"1569566487","weight":4},{"id":"1569565529","weight":7},{"id":"1569556759","weight":6},{"id":"1569565271","weight":2},{"id":"1569561185","weight":4},{"id":"1569566075","weight":2},{"id":"1569566397","weight":8},{"id":"1569566301","weight":6},{"id":"1569558779","weight":2},{"id":"1569566817","weight":3},{"id":"1569566389","weight":3},{"id":"1569564923","weight":5},{"id":"1569566299","weight":4},{"id":"1569564281","weight":2},{"id":"1569564769","weight":5},{"id":"1569565769","weight":6},{"id":"1569566171","weight":2},{"id":"1569566601","weight":4},{"id":"1569565805","weight":3},{"id":"1569563919","weight":3},{"id":"1569566577","weight":3},{"id":"1569557851","weight":3},{"id":"1569565389","weight":2},{"id":"1569559919","weight":2},{"id":"1569565861","weight":7},{"id":"1569566147","weight":5},{"id":"1569565537","weight":4},{"id":"1569559523","weight":2},{"id":"1569560785","weight":3},{"id":"1569565561","weight":6},{"id":"1569560213","weight":2},{"id":"1569555891","weight":2},{"id":"1569565997","weight":7},{"id":"1569565035","weight":14},{"id":"1569564961","weight":17},{"id":"1569559251","weight":3},{"id":"1569567013","weight":3},{"id":"1569566583","weight":2},{"id":"1569561861","weight":2},{"id":"1569565337","weight":3},{"id":"1569565737","weight":4},{"id":"1569560459","weight":4},{"id":"1569564463","weight":2},{"id":"1569565853","weight":9},{"id":"1569550425","weight":10},{"id":"1569566273","weight":2},{"id":"1569564123","weight":12},{"id":"1569565889","weight":4},{"id":"1569566635","weight":3},{"id":"1569566611","weight":2},{"id":"1569551539","weight":2},{"id":"1569564505","weight":3},{"id":"1569565565","weight":4},{"id":"1569565635","weight":4},{"id":"1569561397","weight":3},{"id":"1569565731","weight":3},{"id":"1569566797","weight":5},{"id":"1569566413","weight":2},{"id":"1569565707","weight":6},{"id":"1569565113","weight":2},{"id":"1569566375","weight":2},{"id":"1569565143","weight":3},{"id":"1569564257","weight":2},{"id":"1569565583","weight":4},{"id":"1569566555","weight":3},{"id":"1569565373","weight":3},{"id":"1569566973","weight":4},{"id":"1569561579","weight":2},{"id":"1569566449","weight":2},{"id":"1569566987","weight":2},{"id":"1569565031","weight":2},{"id":"1569551541","weight":2},{"id":"1569566839","weight":2},{"id":"1569551751","weight":3},{"id":"1569558697","weight":2},{"id":"1569565139","weight":11},{"id":"1569566663","weight":3},{"id":"1569565579","weight":2},{"id":"1569566067","weight":2},{"id":"1569566825","weight":2},{"id":"1569566241","weight":7},{"id":"1569564807","weight":3},{"id":"1569563007","weight":2},{"id":"1569566113","weight":8},{"id":"1569566443","weight":2},{"id":"1569566727","weight":13},{"id":"1569565315","weight":5},{"id":"1569566417","weight":2},{"id":"1569560581","weight":4}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S16.T5.4","endtime":"12:50","authors":"Shiva Kumar Planjery, Bane Vasić, David Declercq","date":"1341577800000","papertitle":"Enhancing the Error Correction of Finite Alphabet Iterative Decoders via Adaptive Decimation","starttime":"12:30","session":"S16.T5: Decoding Techniques for LDPC Codes","room":"Kresge Little Theatre (035)","paperid":"1569566533"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral14":"6","spectral20":"14","spectral9":"1","spectral3":"1","spectral17":"2","louvain":"510","spectral10":"6","spectral15":"5","spectral5":"2","spectral8":"2","spectral11":"1","spectral4":"3","spectral12":"5","spectral19":"13","spectral7":"6","spectral13":"1","spectral18":"5","spectral2":"0","spectral16":"5"}}
