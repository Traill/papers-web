{"id":"1569565317","paper":{"title":{"text":"Short Q-ary WOM Codes with Hot/Cold Write Diﬀerentiation"},"authors":[{"name":"Yuval Cassuto"},{"name":"Eitan Yaakobi"}],"abstr":{"text":"California Institute of Technology \t Univ. of California, San Diego EE Department \t ECE Department"},"body":{"text":"As a preparation to discuss WOM codes with two cells (n = 2), we start with the simple case of re-writing using one cell (n = 1). When there is only one cell, any new value of the k input bits has to result in a distinct level increment of the cell between 0 and 2 k − 1. Therefore, it is clear that the number of writes that can be guaranteed with a single cell is t = ⌊ (q − 1)/(2 k − 1)⌋, and no greater. The special case of k = 1 gives t = q − 1 writes by incrementing the level by 1 each time the input bit changes 0 → 1 or 1 → 0 [4]. Since the case of n = 1 is completely characterized, we move to discuss the case of n = 2. With n = 2 cells, the WOM problem becomes interesting as early as k = 3, a case we study next.\nIn an n = 2 code, the physical content of the memory is described by a pair (c 1 , c 2 ) ∈ {0, . . . , q − 1} 2 of cell levels. The information content is represented by an integer number v ∈ { 0, 1, . . . , 2 k − 1} or {0, 1, . . . , 7} for k = 3. A mapping between integers and k-bit vectors is implicitly assumed. Reading information is then performed by a function ψ(c 1 , c 2 ), where ψ : {0, . . . , q − 1} 2 → { 0, 1, . . . , 7}. Writing k bits to the physical cells is speciﬁed as a function µ of the current cell contents and the new information integer. Thus\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\nObserve that the v 1 = (2, 2) vector is exactly the one used in the diagonal stacking of Figure 1. The vector v 2 = (3, −1) is now added to the base to form a complete tiling. The size of this lattice is | det(G)| = 8, and the numbers between 0 and 7 of S are assigned to their respective locations in copies of S translated by T . A truncated version of the inﬁnite tiling T is shown in Figure 2.\nAccording to the lattice tiling shown in Figure 2, every entry (c 1 , c 2 ) in the two-dimensional array is assigned with a number ψ (c 1 , c 2 ) ∈ {0, . . . , 7}. This gives us the decoding procedure of the code. For the update procedure, given the current memory state (c 1 , c 2 ) and an integer m in the range 0 m 7 that represents the new bit values, the new memory state (c \u2032 1 , c \u2032 2 ) satisﬁes the following conditions:\n3) (c \u2032 1 , c \u2032 2 ) minimizes the value of max{c \u2032\u2032 1 , c \u2032\u2032 2 } among all the points (c \u2032\u2032 1 , c \u2032\u2032 2 ) that satisfy conditions 1 and 2.\nProof: Let us consider the four writes of this code, and let (δ i, 1 , δ i, 2 ) be the cell-level increments in each write for i = 1, 2, 3, 4 such that the ﬁnal cell level is\nIf there exists 1 i 4 such that δ i, 1 < 2 then c 1 7 and similarly for c 2 . Hence we only need to consider the case where for all 1 i 4 δ i, 1 = 2 or for all 1 i 4 δ i, 2 = 2. From the tile shape, increments of δ i, 1 = δ i, 2 = 2 are never needed, so at every write at most one of δ i, 1 and δ i, 2 equals 2. Assume without loss of generality that for all 1 i 4 δ i, 1 = 2, then δ i, 2 1. Consider the last write, note that instead of the increment vector (δ 4,1 , δ 4,2 ) = (2, δ 4,2 ), we could use the increment vector (1, δ 4,2 + 3) without violating the decoding\nM = a 2 − (a − b) 2 = (2a − b) · b = 2 · 2 k− 1 2 · 2 k− 1 2 = 2 k . The number of levels is\n     \n     \nWe now move to study a new type of WOM codes, where part of the input bits are allowed to be written multiple times, and another part are only allowed a single write. The former are called hot bits and the latter are called cold bits. The motivation for this model comes from the need of solid-state storage devices to level the wear between frequently and rarely written data blocks, which requires to jointly store them on the same physical cells.\nTo understand the model, we start with a simple example. In Figure 3 we show the level transition diagram of a single cell code for one hot and one cold bit. The stored information bits appear at the bottom of the ﬁgure, the right of which (underlined) is the hot bit. Solid arrow lines represent changes in the hot bit, and dashed arrow lines represent re-writing the same value for the hot bit.\n3 4\nRestricting the cold bit to up to one write allows a total number of writes that equals t = ⌊q/2⌋ (including the one cold write). This is better than the standard n = 1, k = 2 WOM code that gives only t = ⌊(q − 1)/3⌋ writes. It also gives one more write than an n = 1, k = 2 ﬂoating code [4]. Note that the t writes of the hot and cold bit can be performed in any order (moving to the right part of the diagram after a cold write can be done at any level). The following lemma states that the code of Figure 3 is optimal.\nWe now detail a two-cell scheme to jointly store one hot and one cold bit. We start with specifying the decoding rule pictorially in Figure 4. As in the two-cell schemes of the previous section, the coordinates at the exterior of the matrix represent physical-cell levels, and the integers within the matrix are the information content of the stored bits: 0 stands for 00, 1 stands for 01, 2 stands for 10 and 3 stands for 11. The underlined bit is the hot bit that can change multiple times in the write sequence. The non-underlined bit is the cold bit that can be written once, at any point of the write sequence. To support unrestricted re-writing of the hot bit, the following transitions must be possible without decrease in physical-cell levels:\nIn addition, a single transition of the form 0 → 2 or 1 → 3 must be supported.\nThe formal speciﬁcation of the decoding and update rules are now given. Suppose the hot bit is denoted b 1 and the cold\n0 0\n1 1\n2 2\n3 3\n4 4\nb) If c 1 = c 2 > 0, then (c \u2032 1 , c \u2032 2 ) = (c 1 , c 2 + 1). c) If c 1 = c 2 + 2, then (c \u2032 1 , c \u2032 2 ) = (c 1 , c 2 + 1). d) If c 1 = c 2 + 1, then (c \u2032 1 , c \u2032 2 ) = (c 1 + 1, c 2 ). e) If c 2 > c 1 , then (c \u2032 1 , c \u2032 2 ) = (c 1 + 1, c 2 ).\nb) 2 changing to 3 by going up one level. c) 0 changing to 1 by going up one level.\nThe following lemma will help proving the code properties. Lemma 6.\nthe memory achieves state (q − 1, q − 1), after q − 1 + q − 3 alternating +1 changes in c 1 and c 2 (for the hot bit) and a single +2 change in c 2 (for the cold bit). Thus, in that case too there are q − 1 + q − 3 + 1 = 2(q − 1) − 1 writes.\nNote that a trivial upper bound on the number of writes is 2(q − 1). However, it is possible to show that the construction is strictly optimal.\nProof: Assume in the contrary that there exists a code which guarantees 2(q − 1) writes. Let us consider 2(q − 1) − 1 writes where only the hot bit b 1 changes its value. Then, the memory state is either (q − 1, q − 2) or (q − 2, q − 1), and b 1 = 1. Without loss of generality, assume it is the ﬁrst state. Therefore, the decoded value of the memory state (q − 1, q − 2) is (b 1 , b 2 ) = (1, 0). On the following write, it is possible to change the two-bits value to either (0, 0) or (1, 1) but there is only one memory state that is accessible, (q − 1, q − 1), which leads to a contradiction.\nIn this section we would like to extend the 2-cell hot+cold construction of the previous sub-section such that it will be possible to store multiple cold bits and a single hot bit. First, note that we can take k copies of the previous construction, that is, 2k cells. In every pair of cells, a single cold bit is stored and a single hot bit. Since we only need to store a single hot bit, its value is simply the sum of the k hot bits. Thus, it is possible to store a single hot bit and k cold bits in n = 2k cells with k(2q − 3) = n(q − 1) − k writes.\nNext we show another example of such a construction with fewer cells n = k + 1. Let us denote the cells by c 0 , c 1 , . . . , c k . Our idea is similar to the one we just presented, with the cell c 0 acting as a mutual cell to all the other k cells. That is, every two cells of the form (c 0 , c i ) for 1 i k , generate a code of a single hot and a single cold bit. Let us now describe the encoding and decoding rules. We denote the hot bit by b 0 and the cold bits by b 1 , b 2 , . . . , b k . The decoding and encoding maps of the previous construction (Figure 4) are denoted by D(c, c \u2032 ), E(c, c \u2032 , i ), respectively. The new decoding map D ∗ (c 0 , c 1 , . . . , c k ) = (b 0 , b 1 , . . . , b k ) is applied as follows.\n2) For 1 i k , b i = D (c 0 , c i ) 2 (bit 2 of the decoded pair). The new encoding map E ∗ (c 0 , c 1 , . . . , c k , s ) = (c \u2032 0 , c \u2032 1 , . . . , c \u2032 k ), is applied as follows, where 0 s k and (c 0 , c 1 , . . . , c k )\n(c \u2032 0 , c \u2032 1 , . . . , c \u2032 k ). We distinguish between the two cases of whether the hot or a cold bit changes its value.\n2) s = 0 (hot): if there exists 1 i k such that E(c 0 , c i , 1) = (c 0 , c i + 1) then set c \u2032 j = c j for 0 j k and j i , and c \u2032 i = c i + 1. Otherwise (that is, for all 1 i k , E(c 0 , c i , 1) = (c 0 + 1, c i )), set (c \u2032 0 , c \u2032 1 , . . . , c \u2032 k ) = (c 0 + 1, c 1 , . . . , c k ).\nIn this part we extend the 2-cell hot+cold construction of sub-section III-A to storing 2 hot bits and 1 cold bit. As it turns out, the penalty (in the number of writes t) for adding a cold bit to the cells remains negligible even when the number of hot bits is doubled from 1 to 2. Due to lack of space we will only include the pictorial speciﬁcation of the code in Figure 5. The key feature to see in Figure 5 is that changing the cold bit (MSB) is done by moving upward from the solid stack of squares to the dashed one. Updates of the hot bits are done in a diagonal fashion. The re-write capabilities of the code are\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\nThe fact that the pair of hot bits can be written q − 3 times, very close to the q − 1 writes possible in the absence of the cold-bit write, means that the penalty we suﬀer to level the wear between the hot and cold bits is insigniﬁcant."},"refs":[{"authors":[{"name":"A. Fiat"},{"name":"A. Shamir"}],"title":{"text":"Generalized write-once memories"}},{"authors":[{"name":"F. Fu"},{"name":"A. H. Vinck"}],"title":{"text":"On the capacity of generalized write once memory with state transitions described by an arbitrary directed acyclic graph"}},{"authors":[{"name":"R. Gabrys"},{"name":"L. Dolecek"}],"title":{"text":"Characterizing capacity achieving write once memory codes for multilevel ﬂash memories"}},{"authors":[{"name":"A. Jiang"},{"name":"V. Bohossian"},{"name":"J. Bruck"}],"title":{"text":"Rewriting codes for joint infor- mation storage in ﬂash memories"}},{"authors":[{"name":"A. Jiang"},{"name":"M. Langberg"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Trajectory codes for ﬂash memory"}},{"authors":[{"name":"S. Kayser"},{"name":"E. Yaakobi"},{"name":"H. Siegel"},{"name":"A. Vardy"},{"name":"K. Wolf"}],"title":{"text":"Multiple- write WOM-codes"}},{"authors":[{"name":"B. Kurkoski"}],"title":{"text":"Rewriting codes for ﬂash memories based upon lattices, and an example using the E8 lattice"}},{"authors":[{"name":"R. L. Rivest"},{"name":"A. Shamir"}],"title":{"text":"How to reuse a write-once memory"}},{"authors":[{"name":"S. Stei"},{"name":"S. Szab"}],"title":{"text":"Algebra and Tiling"}},{"authors":[{"name":"Y. Wu"},{"name":"A. Jiang"}],"title":{"text":"Position modulation code for rewriting write-once memories"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565317.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S8.T5.3","endtime":"17:40","authors":"Yuval Cassuto, Eitan Yaakobi","date":"1341336000000","papertitle":"Short Q-ary WOM Codes with Hot/Cold Write Differentiation","starttime":"17:20","session":"S8.T5: WOM Codes","room":"Kresge Little Theatre (035)","paperid":"1569565317"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
