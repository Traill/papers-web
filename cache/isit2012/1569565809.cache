{"id":"1569565809","paper":{"title":{"text":"Functional-Repair-by-Transfer Regenerating Codes"},"authors":[{"name":"Kenneth W. Shum"},{"name":"Yuchong Hu"}],"abstr":{"text":"Abstract\u2014 In a distributed storage system, a data ﬁle is distributed to several storage nodes, such that the original ﬁle can be decoded from any subset of the storage nodes of size larger than or equal to a certain threshold. Upon the failure of a storage node, we would like to regenerate it with minimal amount of data transmissions from the surviving nodes to the new node. This performance metric is called the repair-bandwidth. Another performance metric is the disk input/output (I/O) cost, which measures the number of bits a storage node needs to read out from its memory in order to repair the failed node. In this paper, we give examples of linear regenerating codes with minimal disk I/O cost and repair-bandwidth, without any linear mixing in the helping storage nodes.\nIndex Terms\u2014Cloud storage, distributed storage system, re- generating codes, network coding."},"body":{"text":"Regenerating codes, as introduced by Dimakis et al. in [2], is a class of erasure codes for distributed storage systems. A source data ﬁle is encoded across the storage nodes such that a data collector can decode the source data ﬁle by connecting to a fraction of the storage nodes. Should a storage node fail, the failed node can be repaired by downloading some data packets from the surviving nodes. The aim of the design of regenerating codes is to minimize the the total trafﬁc required in the repair process.\nBesides the bandwidth requirement, another metric that arises in practice is the disk I/O cost: we want to minimize the number of bits that a surviving node must read out from its memory during the repair of the failed node. In the extreme case where disk I/O cost is minimal, the number of bits read out from the memory is exactly equal to the number of bits to be sent out. Data combining is only required in the receiving end. Regenerating code with minimal disk I/O cost is called a repair-by-transfer regenerating code. Some constructions of repair-by-transfer regenerating codes attaining minimum repair-bandwidth can be found in [3], [4]. In this paper, we will consider minimum-storage regenerating codes. This class of regenerating codes ﬁnd applications in multiple- cloud storages [5].\nWe give an example of repair-by-transfer regenerating code, which has the same parameters as in the example in [2, Fig. 2], but linear combining is not required in the surviving storage nodes. The encoding of packets are shown in Fig. 1. The ﬁrst\n1st packet 2nd packet Node 1 \t A \t C + D Node 2 \t B \t D + A Node 3 \t C \t A + B Node 4 \t D \t B + C\npacket in each storage node is an uncoded packet, the second one is the sum of two packets, with addition performed in F 2 , the ﬁnite ﬁeld of size 2. Let x ⊕ y denote the unique integer z ∈ {1, 2, 3, 4} such that x + y ≡ i mod 4. The parity-check packets in nodes i ⊕ 2 is the sum of the uncoded packets in node i and node i ⊕1. One can verify that the four information packets can be decoded from any two nodes. For example, from nodes 1 and 3, packets A and C can be obtained directly, and packet B (resp. D) can be decoded by adding packet A (resp. C) to A+B (resp. C +D). If node 1 fails, we can repair it by downloading packets D + A from node 2, packet C from node 3, and packet D from node 4. Packet A can be recovered by adding packets D + A and D, and packet C + D can be recovered by adding packets C and D. By the cyclic structure of the code, nodes 2, 3 and 4 can be repaired similarly. We also note that data update can be performed efﬁciently; should an information packet be updated, we only need to modify one uncoded packet and two parity-check packets in the system.\nThe above example falls under the category of exact repair. In this paper, we consider functional repair. Regenerating codes for functional repair in general is given in Section II and the repair-by-transfer subclass is discussed in Section III. A family of repair-by-transfer regenerating codes for functional repair is detailed in Section IV.\nLet n be the number of storage nodes. A data ﬁle of size M is encoded and distributed to the n storage nodes. The amount of data stored in each node is denoted by α. We divide the time into stages. Initially, the system start at stage 0. After a node failure in stage t, the failed node is repaired and the time is advanced to the (t + 1)-st stage. The design objectives of regenerating code for distributed storage network (DSN) are: (Node repair) Upon the failure of a storage node in stage t, we recover it by setting up a newcomer, who contacts any d surviving nodes, called the helpers, and downloads β units of data from each of them. The total amount of data transmitted from the helpers is called the repair-bandwidth, and is denoted by γ = dβ.\noriginal data ﬁle by downloading from any k storage nodes. We call this property the (n, k) recovery property. If α is equal to M/k, which is the minimum possible value for α, then the system is said to be maximal-distance separable (MDS).\nAny code which realizes the (n, k) recovery property and repairs a failed node by connecting to d surviving nodes is called an (n, d, k) regenerating code, or simply a regenerating code if the parameters are understood from the context.\nThere are two modes of repair. The ﬁrst one is called func- tional repair and the second one is exact repair. In functional repair, the content of the newcomer is not necessarily the same as the content in the failed storage nodes. Only the (n, k) recovery property is preserved. In exact repair, the content of the newcomer should be exactly the same as in the failed node.\nFor a given α, there is a fundamental limit for the repair cost measured in terms of the repair-bandwidth. For functional repair, a lower bound of repair-bandwidth can be derived via the max-ﬂow bound for single-source multicasting [2]. In the MDS case, the lower bound on repair-bandwidth is given by,\nIt is proved in [6] that for functional repair, the lower bound of repair-bandwidth in (1) can be achieved by linear network code over a ﬁxed ﬁnite ﬁeld. In the following, we describe the realization of regenerating codes by linear network codes. Let q be a prime power and let the ﬁnite ﬁeld of size q be denoted by F q . The parameters B, α and β of the DSN are all integers. In the following, we will refer to an element in F q as a packet as well.\nThe ﬁle is divided into many stripes of data, each consisting of B packets. Each stripe of data will be encoded in the same way. In the remaining of this paper we will focus on one stripe of data, and suppose that the data ﬁle consists of B packets, m 1 , m 2 , . . . , m B . These B symbols are called the message symbols.\nEach of the n storage nodes stores α packets, obtained by taking some linear combinations of the message symbols. The vector formed by the B coefﬁcients of the linear combination associated to a packet is called the global encoding vector of the packet. In the t-th stage, we denote the global encoding vector of the j-th packet stored in the i-th node by Γ t (i, j), for i = 1, 2, . . . , n and j = 1, 2, . . . , α. Thus, the j-th packet in the i-th node is equal to the dot product of Γ t (i, j) and [m 1 m 2 . . . m B ]. We call (i, j) the index of the vector Γ t (i, j).\nWe will view Γ t (i, j) as a function, mapping an index (i, j) to a global encoding vector in stage t. The deﬁnition of Γ t is extended as a function with sets of indices as domain by deﬁning\nLet G (t) i be the α × B encoding matrix whose rows are precisely the global encoding vectors Γ t (i, 1), . . . , Γ t (i, α), and m be the column vector [m 1 m 2 . . . m B ] T . (We will use superscript (t) to indicate that a variable associated with\nstage t, and superscript T for the transpose operator.) The packets stored within the i-th node in the t-th stage are the components in G (t) i m. The DSN is initialized such that at stage 0, the global encoding vectors in any k storage nodes form a full-rank matrix.\nSuppose that node i fails in stage t, and the helpers are nodes h 1 , h 2 , . . . , h d . For j = 1, 2, . . . , d, helper h j sends β packets to the newcomer. Let F (t) h\nbe the β ×α local encoding matrix of helper h d at stage t. The packets sent from helper h d to the newcomer are the components in\nThe newcomer takes some linear combinations of the received packets, and compute α packets by\n   \n  \nwhere H (t) i is an α × (dβ) matrix over F q . After the repair process in stage t, the global encoding matrices can be updated by\n     \n    \n   \n  \nIf we want to repair the DSN exactly, the encoding matrix G (t+1) j \t should equal G (t) j for all j. For functional repair, we just want to maintain the (n, k) recovery property, namely, at any stage and in any set of k storage nodes, the rank of the kα global encoding vectors is equal to B.\nIn a repair-by-transfer regenerating code, we choose the local encoding matrix F (t) h\nsuch that there is exactly one 1 in each row, while the other entries are all zero. In the remaining of this paper, we will focus on (n, n − 1, 2) repair-by-transfer regenerating codes for functional repair, with parameters\nd = n − 1, k = 2,\nB = k(d + 1 − k) = 2(n − 2), α = B/k = n − 2, and β = 1,\ni.e., any two storage nodes are sufﬁcient in rebuilding the original ﬁle, and each node stores B/2 packets (the MDS case). Any regenerating code with the above parameters is optimal with respect to the bound in (1).\nFor repair-by-transfer regenerating code with the above parameters, the local encoding matrix F (t) j is a zero-one row vector. If node ℓ t fails in stage t, for j ̸= ℓ t , we let χ(t, ℓ t , j) be the index of the unique \u201c1\u201d in F (t) j , i.e., node j sends\npacket χ(t, ℓ t , j) to node ℓ t . The function χ(t, ℓ t , j) is called the choice function, and takes value between 1 and α. Let\nbe the set of indices of the global encoding vectors used in the repair of node ℓ t .\nFor example, in Fig. 1, if node 1 fails, we can repair node 1 using packets C, A + C, and B + C from nodes 2, 3, and 4, respectively. The choice function is χ(t, 1, 2) = 1, χ(t, 1, 3) = 1 and χ(t, 1, 4) = 2, and we have R t (4) = {(2, 1), (3, 1), (4, 2)}.\nIn case node ℓ t fails in stage t, the repair-by-transfer process consists of the following steps:\n(i) For j ̸= ℓ t , node j sends the χ(t, ℓ t , j)-th packet in its memory to the newcomer.\n(ii) Put the packets received by the newcomer together as a column vector and multiply it by an α ×(n−1) local encoding matrix H (t) ℓ\n. Update the global encoding matrix of the newly reconstructed node to\n         \n         \n(iii) Determine the choice function for the repair in the next stage, χ(t + 1, i \u2032 , j \u2032 ), for i \u2032 ̸= ℓ t and j \u2032 ∈ {1, 2, . . . , α} \\ {i \u2032 }.\nThe (n, 2) property requires that for any t, the global encoding vectors indexed by C i,j , with i ̸= j, in stage t are linearly independent.\nExample 1. Consider a (5, 4, 2) regenerating code. In stage t, the global encoding vectors can be tabulated as\nNode 1 Γ t (1, 1) Γ t (1, 2) Γ t (1, 3) Node 2 Γ t (2, 1) Γ t (2, 2) Γ t (2, 3) Node 3 Γ t (3, 1) Γ t (3, 2) Γ t (3, 3) Node 4 Γ t (4, 1) Γ t (4, 2) Γ t (4, 3) Node 5 Γ t (5, 1) Γ t (5, 2) Γ t (5, 3)\nSuppose that node 1 fails in stage t, and we want to repair node 1 by the ﬁrst packets Γ t (2, 1), Γ t (3, 1), Γ t (4, 1) and Γ t (5, 1) in node 2 to node 5 respectively. In order to maintain the (n, 2) recovery property in stage t + 1, we need to guarantee that after the repair, each of the ﬁve sets of global encoding vectors, Γ t+1 ( C 1,2 ), Γ t+1 ( C 1,3 ), Γ t+1 ( C 1,4 ), and Γ t+1 ( C 1,5 ) are linearly independent.\nThe set S t (ℓ t , j) is interpreted as the index set of the packets of node j and the packets used in repairing node ℓ t in stage t.\nS t (1, 2) = {(2, 1), (2, 2), (2, 3), (3, 1), (4, 1), (5, 1)}, S t (1, 3) = {(3, 1), (3, 2), (3, 3), (2, 1), (4, 1), (5, 1)}, S t (1, 4) = {(4, 1), (4, 2), (4, 3), (2, 1), (3, 1), (5, 1)}, S t (1, 5) = {(5, 1), (5, 2), (5, 3), (2, 1), (3, 1), (4, 1)}.\nGraphically, these four sets of indices can be illustrated by the following arrays:\nWe note that for ℓ t ̸= j, the set S t (ℓ t , j) consists of 2(n − 2) elements, because |C j | = n − 2, |R t (ℓ t ) | = n − 1, and |C j ∩ R t (ℓ t ) | = 1. When ℓ t = j, |S t (ℓ t , j) | = 2n − 3.\nSuppose that the (n, 2) recovery property holds in stage t. In order to maintain the (n, 2) recovery property after the repair of node ℓ t , we need to check that each of the following sets of global encoding vectors Γ t+1 ( C ℓ t ,j ), for j ∈ {1, 2, . . . , n} \\ {ℓ t }, are linearly independent. (We do not need to check Γ t+1 ( C j,j \u2032 ) for j ̸= ℓ t ̸= j \u2032 because Γ t ( C j,j \u2032 ) = Γ t+1 ( C j,j \u2032 ).)\n(i) Each vector in Γ t+1 ( C ℓ t ,j ) can be obtained as a linear combination of the vectors in Γ t ( S t (ℓ t , j)). Therefore, if the vectors in Γ t ( S t (ℓ t , j)) are linearly dependent, then the vectors in Γ t+1 ( C ℓ t ,j ) are also linearly dependent.\n(ii) If the vectors in Γ t ( S t (ℓ t , j)) are linearly independent, then we can choose a local encoding matrix H (t) ℓ\nin stage t such that the vectors in Γ t+1 ( C ℓ t ,j ) are linearly independent. In fact, we can use a (n − 2) × (n − 1) matrix H whose (r, s)-entry is\n1 s = r, or s = r + 1 0 otherwise,\nat the newcomer, in all stage t and for all node ℓ t being repaired. For example if n =\neliminating any column matrix, the resulting square matrix has full rank. This proves that for each j ̸= ℓ t , we can choose H (t) ℓ\nsuch that a newcomer in the next stage can decode the original data ﬁle from the packets in nodes j and ℓ t .\nA standard application of the Schwartz-Zippel\u2019s lemma in network coding theory [7] shows that there is a choice of H (t) ℓ\nsuch that all data collectors in the next stage are satisﬁed, if the ﬁnite ﬁeld size is large enough. This gives the following lemma.\nLemma 1. Suppose that node ℓ t fails in stage t, and the choice function χ is given. If for each j ̸= ℓ t , the set of vectors in Γ t ( S t (ℓ t , j)) are linearly independent, then we can choose H (t) ℓ\nsuch that the vectors in Γ t+1 ( C ℓ t ,j ) are linearly independent for all j ̸= ℓ t , provided that the underlying ﬁnite ﬁeld is sufﬁciently large.\nThe intuition from Lemma 1 is as follows. The (n, 2) recov- ery property per se requires that the global encoding vectors in any two storage nodes are linearly independent. However, in order to sustain the (n, 2) recovery property through repair-by- transfer, we need to ensure the linear independence of many other sets of global encoding vectors. The next lemma serves as a tool for this purpose. Recall that for a set X of indices, the notation Γ t ( X ) stands for the set of global encoding vector corresponding to the indices in X in stage t.\nLemma 2. Suppose that node ℓ t fails in stage t, and packets with indices R t (ℓ t ) are used to repaired node ℓ t . Let X and Y be two sets of indices of global encoding vectors in stage t and t + 1 respectively, such that Y \\ X ⊆ C ℓ t and X \\ Y ⊆ R t (ℓ t ). If the set of vectors in Γ t ( X ) are linearly independent, then we can choose the local encoding matrix in stage t such that the vectors in Γ t+1 ( Y) are linearly independent.\nThe choice function χ has to be carefully chosen, oth- erwise the (n, 2) recovery property cannot be preserved for unbounded number of stages. As a counter-example, suppose that in Example 1 we always pick the ﬁrst packets in the memory of the surviving nodes in the repair process, i.e., the function χ(t, ℓ t , j) is identically equal to 1 in all stages. Then the dimension of the span of totality of encoding vectors in all nodes will eventually drop to four or less. As the dimension of the original data ﬁle is six, the data recovery will doom to failure.\nThe main theorem in this paper is that there is an appropriate choice function which preserve the (n, 2) recovery property through repair-by-transfer.\nTheorem 3. For all n ≥ 4, there exists an (n, n − 1, 2) MDS repair-by-transfer regenerating code for functional re- pair, meeting the lower bound on repair-bandwidth in (1). Moreover, the ﬁnite ﬁeld size can be chosen to be any prime power larger than\nWe will only sketch the proof of Theorem 3 in this section, and go through an example for illustration. The idea of proof is to come up with a choice function χ(t, i, j) and local encoding matrix H (t) i , such that there are sufﬁciently many sets of linearly independent global encoding vectors in every stage.\nWe let B = k(d+1 −k) = 2(n−2), α = n−2 and β = 1, by normalizing the unit if necessary. In the proof of Theorem 3, we assume that no node will fail in two consecutive stages, because, say if node i fails in stage t and t + 1, we can repeat the repair procedure taken in stage t.\nIt is well-known that under the condition q + 1 ≥ n(n − 2), we can construct n(n −2) vectors of length B with components drawn from F q , such that every subset of B vectors are linearly independent over F q [8]. (These vectors form a generating ma- trix of a maximal-distance separable (MDS) code of dimension B over F q .) In stage 0, we take these n(n − 2) vectors as the initial global encoding vectors. Since any set of B of them are linear independent by construction, the global encoding vectors in any two storage nodes are linear independent. Thus the (n, 2) recover property holds in the initial stage.\nWe will display a choice function by a sequence of n × (n − 2) arrays. For each t ≥ 0, we create an n × (n − 2) array and write \u201ci\u201d in the r-th row and the χ(t, i, r)-th column. The array associated with stage t is interpreted as follows. If node i fails in stage t, for r ̸= i, node r sends the j-th packet to node i if the j-th column in the array in stage t is labeled by i.\nAn example for n = 5 is shown in Fig. 2. In stage 0, we initialize χ(0, i, j) = 1 for all i and j, i.e., no matter which node fails, the surviving nodes send their ﬁrst packets to the newcomer. In the r-th row, we write the element in {1, 2, . . . , 5} \\ {r} in the column labeled by \u201cPacket 1\u201d. Suppose that node 1 fails in stage 0, i.e., ℓ 0 = 1. The new- comer receives packets with global encoding vector Γ 0 (2, 1), Γ 0 (3, 1), Γ 0 (4, 1) and Γ 0 (5, 1). The indices of these four packets are R 0 (1) = {(2, 1), (3, 1), (4, 1), (5, 1)}. The packets in the repaired node 1 are linear combinations of these four packets. Then, we specify the choice function for stage t = 1. From the hypothesis that no node fails in two consecutive stages, node 1 will not fail in stage 1. The 5 ×3 array associated with stage 1 does not contain the label \u201c1\u2019. We design the choice function by evenly \u201cspreading\u201d the labels 2 to 5 in the array. In rows 2 to 5, each entry in the array contains exactly one label. Each packet is potentially used in the repair process after stage 1, depending on which node fails in stage 1. This \u201cevenly spread\u201d property is expressed mathematically as\nProperty (a): For j ̸= ℓ t −1 , χ(t, i, j) = χ(t, i \u2032 , j) only if i = i \u2032 .\nFrom the discussion at the beginning of this section, we try to avoid using the same packet in the repair process of two consecutive stages. This motivates the second heuristics in the design of the choice function. Since the ﬁrst packets in nodes 2 to 5 have been used in the repair process before stage 1, we want to impose the requirement that at most one of these four packets are used again in the repair process after stage 1. As there are four possible node failures in stage 1, this implies that exactly one of these four packets is used in the repair of the node failure in stage 1. Indeed, the choice function at stage 1 satisﬁes this requirement. The four entries under \u201cPacket 1\u201d, corresponding to nodes 2 to 5, are distinct.\nSuppose node 2 fails in stage 1. Node 1 and 5 send the ﬁrst packets in their memory to the newcomer, while nodes 3 and 4 send the last packets in their memory to the newcomer. The indices of these four packets are R 1 (2) = {(1, 1), (3, 3), (4, 3), (5, 1)}. We note that only the ﬁrst packet in node 5 is used twice in the repair after stage 0 and stage 1. In\nset-theoretical terms, we can write R 0 (1) ∩ R 1 (2) = {(5, 1)}. The choice function for t = 2 is illustrated in the array\nunder \u201cStage 2\u201d in Fig. 2. We note that the choice function in stage 2 satisﬁes Property (a), i.e., for r ∈ {1, 3, 4, 5}, each entry in row r contains exactly one label. Also, the label \u201c2\u201d does not appear, because it is assumed that node 2 will not fail in stage 2. We can check that\nR 1 (2) ∩ R 2 (1) = {(3, 3)}, R 1 (2) ∩ R 2 (3) = {(1, 1)}, R 1 (2) ∩ R 2 (4) = {(5, 1)}, R 1 (2) ∩ R 2 (5) = {(4, 3)}.\nWe write X t,ℓ t −→ Y if Y and X satisfy the condition in Lemma 2. Under the choice function as in Fig. 2, and ℓ 0 = 1, ℓ 1 = 2, we illustrate the proof idea using the following ﬁgure:\nThe asterisks in each array indicate a set of six global encoding vectors. In stage 2, it is required that the global encoding vectors in nodes 1 and 2 are linearly independent. By Lemma 1, this can be guaranteed if the global encoding vectors\nin stage 0 are linearly independent. We initialize the global encoding vectors in stage 0 in such a way that any six global encoding vectors are linearly independent. Hence, in stage 2, with suitable choice of local encoding matrices, the six global encoding vectors in nodes 1 and 2 are linearly independent.\nThe main idea of proof is that the above example can be generalized to all C i,j in all stages, provided that the choice function satisﬁes Properties (a) and (b), and some other technical conditions. The details of the proof is omitted due to space limitation.\nWe give an existence proof of a family of MDS regenerating codes with the property that failed node is repaired by transfer- ring packets received in earlier time. This can be regarded as a linear code with coefﬁcients restricted to {0, 1}. In a recent work by Wang et al. in [9], a construction of MDS exact- repair regenerating code with optimal disk I/O cost for any k is given. Their construction differs from the construction in this paper as being a vector linear regenerating code; the data sent from a surviving node to the newcomer is divided into many fragments, and each fragment is a linear combination of the source data (β > 1). The regenerating code considered in this paper is scalar linear regenerating codes (β = 1). Another vector linear regenerating code for repairing the systematic nodes only can be found in [10].\nThe authors would like to thank Raymond Yeung for the useful discussions."},"refs":[{"authors":[{"name":"K. W. Shum"},{"name":"Y. Hu"}],"title":{"text":"Repair-by-transfer in distributed storage system"}},{"authors":[{"name":"A. G. Dimakis"},{"name":"P. B. Godfrey"},{"name":"Y. Wu"},{"name":"M. J. Wainwright"},{"name":"K. Ram- chandran"}],"title":{"text":"Network coding for distributed storage systems"}},{"authors":[{"name":"S. El Rouayheb"},{"name":"K. Ramchandran"}],"title":{"text":"Fractional repetition codes for repair in distributed storage systems"}},{"authors":[{"name":"N. B. Shah"},{"name":"K. V. Rashmi"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Dis- tributed storage codes with repair-by-transfer and non-achievability of interior points on the storage-bandwidth tradeoff"}},{"authors":[{"name":"Y. Hu"},{"name":"H. C. H. Chen"},{"name":"P. P. C. Lee"},{"name":"Y. Tang"}],"title":{"text":"NCCloud: Applying network coding for the storage repair in a cloud-of-clouds"}},{"authors":[{"name":"Y. Wu"}],"title":{"text":"Existence and construction of capacity-achieving network codes for distributed storage"}},{"authors":[{"name":"R. K¨otter"},{"name":"M. M´edard"}],"title":{"text":"An algebraic approach to network coding"}},{"authors":[{"name":"R. M. Rot"}],"title":{"text":"Introduction to Coding Theory"}},{"authors":[{"name":"Z. Wang"},{"name":"I. Tamo"},{"name":"J. Bruck"}],"title":{"text":"On codes for optimal rebuilding access"}},{"authors":[{"name":"V. R. Cadambe"},{"name":"C. Huang"},{"name":"J. Li"},{"name":"S. Mehrotra"}],"title":{"text":"Polynomial length MDS codes with optimal repair in distributed storage"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565809.pdf"},"links":[{"id":"1569566567","weight":2},{"id":"1569564843","weight":4},{"id":"1569566527","weight":3},{"id":"1569565883","weight":9},{"id":"1569564889","weight":2},{"id":"1569565377","weight":2},{"id":"1569565867","weight":5},{"id":"1569566799","weight":4},{"id":"1569559665","weight":2},{"id":"1569564669","weight":16},{"id":"1569565691","weight":29},{"id":"1569566875","weight":5},{"id":"1569564605","weight":3},{"id":"1569559617","weight":2},{"id":"1569566981","weight":2},{"id":"1569566321","weight":2},{"id":"1569566605","weight":5},{"id":"1569566683","weight":2},{"id":"1569566855","weight":3},{"id":"1569566869","weight":7},{"id":"1569565097","weight":4},{"id":"1569566227","weight":10},{"id":"1569566091","weight":2},{"id":"1569559259","weight":3},{"id":"1569566697","weight":3},{"id":"1569566597","weight":3},{"id":"1569565551","weight":2},{"id":"1569566761","weight":2},{"id":"1569566943","weight":2},{"id":"1569565091","weight":10},{"id":"1569566591","weight":11},{"id":"1569566571","weight":12},{"id":"1569552245","weight":3},{"id":"1569565607","weight":17},{"id":"1569565495","weight":3},{"id":"1569559967","weight":2},{"id":"1569567045","weight":2},{"id":"1569564481","weight":3},{"id":"1569566415","weight":4},{"id":"1569564805","weight":7},{"id":"1569567005","weight":5},{"id":"1569566081","weight":11},{"id":"1569565613","weight":15},{"id":"1569566373","weight":6},{"id":"1569566647","weight":2},{"id":"1569551535","weight":3},{"id":"1569564897","weight":4},{"id":"1569565775","weight":2},{"id":"1569566871","weight":2},{"id":"1569566653","weight":4},{"id":"1569565461","weight":3},{"id":"1569564731","weight":2},{"id":"1569565171","weight":2},{"id":"1569566207","weight":6},{"id":"1569564227","weight":2},{"id":"1569558325","weight":5},{"id":"1569565837","weight":3},{"id":"1569566671","weight":3},{"id":"1569566303","weight":2},{"id":"1569564233","weight":2},{"id":"1569566459","weight":7},{"id":"1569563411","weight":3},{"id":"1569560427","weight":2},{"id":"1569564849","weight":4},{"id":"1569559541","weight":5},{"id":"1569566319","weight":2},{"id":"1569565123","weight":2},{"id":"1569566941","weight":7},{"id":"1569555811","weight":3},{"id":"1569558459","weight":3},{"id":"1569565291","weight":35},{"id":"1569564203","weight":7},{"id":"1569566821","weight":3},{"id":"1569566467","weight":2},{"id":"1569566157","weight":2},{"id":"1569566903","weight":6},{"id":"1569565859","weight":3},{"id":"1569564249","weight":2},{"id":"1569566843","weight":3},{"id":"1569566579","weight":2},{"id":"1569558483","weight":2},{"id":"1569566563","weight":7},{"id":"1569566089","weight":4},{"id":"1569556091","weight":2},{"id":"1569565347","weight":3},{"id":"1569566925","weight":4},{"id":"1569564387","weight":17},{"id":"1569566497","weight":19},{"id":"1569566795","weight":22},{"id":"1569561679","weight":5},{"id":"1569566709","weight":6},{"id":"1569566015","weight":9},{"id":"1569565897","weight":2},{"id":"1569551763","weight":2},{"id":"1569565953","weight":7},{"id":"1569566895","weight":56},{"id":"1569566889","weight":7},{"id":"1569566269","weight":3},{"id":"1569564189","weight":2},{"id":"1569561513","weight":5},{"id":"1569564613","weight":4},{"id":"1569567009","weight":6},{"id":"1569566865","weight":2},{"id":"1569565321","weight":9},{"id":"1569558785","weight":2},{"id":"1569564647","weight":11},{"id":"1569566193","weight":11},{"id":"1569565907","weight":2},{"id":"1569564311","weight":2},{"id":"1569565803","weight":2},{"id":"1569565785","weight":3},{"id":"1569566167","weight":2},{"id":"1569566679","weight":17},{"id":"1569565989","weight":16},{"id":"1569566575","weight":4},{"id":"1569563981","weight":2},{"id":"1569561085","weight":2},{"id":"1569559565","weight":2},{"id":"1569566905","weight":2},{"id":"1569563307","weight":3},{"id":"1569566063","weight":7},{"id":"1569555999","weight":5},{"id":"1569566759","weight":3},{"id":"1569559195","weight":3},{"id":"1569566149","weight":4},{"id":"1569559995","weight":8},{"id":"1569566657","weight":4},{"id":"1569558859","weight":4},{"id":"1569565199","weight":20},{"id":"1569565213","weight":2},{"id":"1569565365","weight":5},{"id":"1569566643","weight":3},{"id":"1569566511","weight":3},{"id":"1569565841","weight":14},{"id":"1569566369","weight":2},{"id":"1569566531","weight":7},{"id":"1569567665","weight":2},{"id":"1569561143","weight":4},{"id":"1569566581","weight":2},{"id":"1569565833","weight":2},{"id":"1569566489","weight":2},{"id":"1569565535","weight":12},{"id":"1569562867","weight":8},{"id":"1569565667","weight":2},{"id":"1569566325","weight":15},{"id":"1569566423","weight":3},{"id":"1569565257","weight":2},{"id":"1569564795","weight":6},{"id":"1569559805","weight":6},{"id":"1569566437","weight":2},{"id":"1569558901","weight":2},{"id":"1569565735","weight":4},{"id":"1569559111","weight":3},{"id":"1569566687","weight":2},{"id":"1569553537","weight":3},{"id":"1569565427","weight":3},{"id":"1569566403","weight":2},{"id":"1569552251","weight":3},{"id":"1569564441","weight":2},{"id":"1569566231","weight":5},{"id":"1569565501","weight":3},{"id":"1569566445","weight":2},{"id":"1569566649","weight":6},{"id":"1569566791","weight":2},{"id":"1569565559","weight":3},{"id":"1569565655","weight":3},{"id":"1569566127","weight":2},{"id":"1569565151","weight":5},{"id":"1569558985","weight":2},{"id":"1569563763","weight":4},{"id":"1569565087","weight":64},{"id":"1569566473","weight":9},{"id":"1569564857","weight":52},{"id":"1569566913","weight":3},{"id":"1569566809","weight":4},{"id":"1569566629","weight":2},{"id":"1569566257","weight":10},{"id":"1569565033","weight":4},{"id":"1569565817","weight":2},{"id":"1569565847","weight":18},{"id":"1569564353","weight":3},{"id":"1569565887","weight":2},{"id":"1569566141","weight":3},{"id":"1569565633","weight":3},{"id":"1569566661","weight":3},{"id":"1569565279","weight":3},{"id":"1569555879","weight":3},{"id":"1569566115","weight":7},{"id":"1569565219","weight":8},{"id":"1569558509","weight":2},{"id":"1569566003","weight":2},{"id":"1569565595","weight":2},{"id":"1569565185","weight":27},{"id":"1569566773","weight":6},{"id":"1569566037","weight":2},{"id":"1569566223","weight":3},{"id":"1569566553","weight":7},{"id":"1569564969","weight":2},{"id":"1569565029","weight":12},{"id":"1569566505","weight":8},{"id":"1569565933","weight":2},{"id":"1569566191","weight":2},{"id":"1569567033","weight":2},{"id":"1569565527","weight":3},{"id":"1569566853","weight":4},{"id":"1569567029","weight":4},{"id":"1569565363","weight":3},{"id":"1569566159","weight":2},{"id":"1569566695","weight":3},{"id":"1569566051","weight":10},{"id":"1569561379","weight":2},{"id":"1569565909","weight":3},{"id":"1569561123","weight":7},{"id":"1569565467","weight":2},{"id":"1569567235","weight":2},{"id":"1569565441","weight":7},{"id":"1569565311","weight":5},{"id":"1569566667","weight":2},{"id":"1569566297","weight":2},{"id":"1569566893","weight":3},{"id":"1569566317","weight":9},{"id":"1569560997","weight":2},{"id":"1569566407","weight":2},{"id":"1569560349","weight":3},{"id":"1569566501","weight":2},{"id":"1569565741","weight":4},{"id":"1569566275","weight":2},{"id":"1569566481","weight":13},{"id":"1569565545","weight":3},{"id":"1569566857","weight":15},{"id":"1569565961","weight":5},{"id":"1569566245","weight":4},{"id":"1569560503","weight":2},{"id":"1569566229","weight":2},{"id":"1569562551","weight":2},{"id":"1569565415","weight":3},{"id":"1569555367","weight":2},{"id":"1569561623","weight":2},{"id":"1569564485","weight":2},{"id":"1569566631","weight":3},{"id":"1569565571","weight":2},{"id":"1569565885","weight":2},{"id":"1569566177","weight":3},{"id":"1569565493","weight":7},{"id":"1569557633","weight":2},{"id":"1569566805","weight":4},{"id":"1569559199","weight":2},{"id":"1569566293","weight":2},{"id":"1569565665","weight":5},{"id":"1569566831","weight":2},{"id":"1569565523","weight":2},{"id":"1569557715","weight":3},{"id":"1569564175","weight":2},{"id":"1569566983","weight":4},{"id":"1569566779","weight":15},{"id":"1569566097","weight":3},{"id":"1569566479","weight":19},{"id":"1569556361","weight":2},{"id":"1569566873","weight":3},{"id":"1569565765","weight":4},{"id":"1569565925","weight":6},{"id":"1569565435","weight":2},{"id":"1569565263","weight":2},{"id":"1569565093","weight":2},{"id":"1569565385","weight":2},{"id":"1569565575","weight":2},{"id":"1569565919","weight":3},{"id":"1569565181","weight":4},{"id":"1569566711","weight":4},{"id":"1569565241","weight":3},{"id":"1569566927","weight":10},{"id":"1569565661","weight":9},{"id":"1569566887","weight":59},{"id":"1569565273","weight":2},{"id":"1569552037","weight":2},{"id":"1569564919","weight":5},{"id":"1569566737","weight":2},{"id":"1569566429","weight":3},{"id":"1569566917","weight":8},{"id":"1569566035","weight":19},{"id":"1569565353","weight":11},{"id":"1569564683","weight":3},{"id":"1569564305","weight":2},{"id":"1569564283","weight":2},{"id":"1569564291","weight":3},{"id":"1569566691","weight":2},{"id":"1569565421","weight":2},{"id":"1569566547","weight":2},{"id":"1569566651","weight":2},{"id":"1569566823","weight":2},{"id":"1569566677","weight":2},{"id":"1569565349","weight":9},{"id":"1569552025","weight":2},{"id":"1569566137","weight":4},{"id":"1569565829","weight":2},{"id":"1569566283","weight":5},{"id":"1569566529","weight":7},{"id":"1569565375","weight":2},{"id":"1569566715","weight":3},{"id":"1569565237","weight":5},{"id":"1569566819","weight":3},{"id":"1569565041","weight":4},{"id":"1569564703","weight":2},{"id":"1569565541","weight":3},{"id":"1569566813","weight":3},{"id":"1569566771","weight":3},{"id":"1569562277","weight":2},{"id":"1569566641","weight":4},{"id":"1569565425","weight":3},{"id":"1569564247","weight":2},{"id":"1569564437","weight":2},{"id":"1569566533","weight":7},{"id":"1569564861","weight":27},{"id":"1569566487","weight":4},{"id":"1569565529","weight":6},{"id":"1569556759","weight":3},{"id":"1569566619","weight":2},{"id":"1569566075","weight":4},{"id":"1569566397","weight":4},{"id":"1569566301","weight":12},{"id":"1569558779","weight":3},{"id":"1569565233","weight":2},{"id":"1569563721","weight":2},{"id":"1569566001","weight":2},{"id":"1569566817","weight":2},{"id":"1569564157","weight":2},{"id":"1569566389","weight":3},{"id":"1569567483","weight":2},{"id":"1569564923","weight":16},{"id":"1569565367","weight":2},{"id":"1569566299","weight":4},{"id":"1569565039","weight":2},{"id":"1569564769","weight":5},{"id":"1569565769","weight":4},{"id":"1569566601","weight":26},{"id":"1569565805","weight":2},{"id":"1569563919","weight":3},{"id":"1569557851","weight":2},{"id":"1569567691","weight":2},{"id":"1569559919","weight":4},{"id":"1569565861","weight":4},{"id":"1569566147","weight":3},{"id":"1569565561","weight":12},{"id":"1569555891","weight":2},{"id":"1569565997","weight":6},{"id":"1569565035","weight":12},{"id":"1569559597","weight":2},{"id":"1569564961","weight":10},{"id":"1569559251","weight":2},{"id":"1569567013","weight":4},{"id":"1569561861","weight":4},{"id":"1569565337","weight":3},{"id":"1569560459","weight":8},{"id":"1569566807","weight":2},{"id":"1569565853","weight":7},{"id":"1569550425","weight":12},{"id":"1569566273","weight":4},{"id":"1569564123","weight":19},{"id":"1569565889","weight":2},{"id":"1569566635","weight":25},{"id":"1569566611","weight":4},{"id":"1569551539","weight":2},{"id":"1569564505","weight":2},{"id":"1569565565","weight":3},{"id":"1569565635","weight":2},{"id":"1569561397","weight":2},{"id":"1569565731","weight":3},{"id":"1569556327","weight":2},{"id":"1569566797","weight":4},{"id":"1569565707","weight":6},{"id":"1569565113","weight":2},{"id":"1569565143","weight":2},{"id":"1569564257","weight":3},{"id":"1569565583","weight":3},{"id":"1569566555","weight":2},{"id":"1569565373","weight":3},{"id":"1569566973","weight":15},{"id":"1569551541","weight":2},{"id":"1569566839","weight":4},{"id":"1569565139","weight":18},{"id":"1569565579","weight":18},{"id":"1569566825","weight":3},{"id":"1569566241","weight":8},{"id":"1569564807","weight":2},{"id":"1569563007","weight":5},{"id":"1569566113","weight":2},{"id":"1569566443","weight":2},{"id":"1569566727","weight":10},{"id":"1569565315","weight":6},{"id":"1569566417","weight":17},{"id":"1569560581","weight":4},{"id":"1569559233","weight":2}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S7.T5.3","endtime":"15:40","authors":"Kenneth W. Shum, Yuchong Hu","date":"1341328800000","papertitle":"Functional-Repair-by-Transfer Regenerating Codes","starttime":"15:20","session":"S7.T5: Regenerating Codes","room":"Kresge Little Theatre (035)","paperid":"1569565809"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"5","spectral14":"8","spectral20":"7","spectral9":"3","spectral3":"1","spectral17":"4","louvain":"31","spectral10":"0","spectral15":"14","spectral5":"4","spectral8":"2","spectral11":"6","spectral4":"2","spectral12":"6","spectral19":"9","spectral7":"6","spectral13":"2","spectral18":"6","spectral2":"0","spectral16":"3"}}
