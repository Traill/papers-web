{"id":"1569558697","paper":{"title":{"text":"Generalized Distributive Law for ML Decoding of STBCs: Further Results"},"authors":[{"name":"Lakshmi Prasad Natarajan"},{"name":"B. Sundar Rajan"}],"abstr":{"text":"Abstract\u2014The problem of designing good Space-Time Block Codes (STBCs) with low maximum-likelihood (ML) decoding complexity has gathered much attention in the literature. All the known low ML decoding complexity techniques utilize the same approach of exploiting either the multigroup decodable or the fast-decodable (conditionally multigroup decodable) structure of a code. We refer to this well known technique of decoding STBCs as Conditional ML (CML) decoding. In [1], we introduced a framework to construct ML decoders for STBCs based on the Generalized Distributive Law (GDL) and the Factor-graph based Sum-Product Algorithm, and showed that for two speciﬁc families of STBCs, the Toepltiz codes and the Overlapped Alamouti Codes (OACs), the GDL based ML decoders have strictly less complexity than the CML decoders. In this paper, we introduce a \u2018traceback\u2019 step to the GDL decoding algorithm of STBCs, which enables roughly 4 times reduction in the complexity of the GDL decoders proposed in [1]. Utilizing this complexity reduction from \u2018traceback\u2019, we then show that for any STBC (not just the Toeplitz and Overlapped Alamouti Codes), the GDL decoding complexity is strictly less than the CML decoding complexity. For instance, for any STBC obtained from Cyclic Division Algebras that is not multigroup or conditionally multigroup decodable, the GDL decoder provides approximately 12 times reduction in complexity compared to the CML decoder. Similarly, for the Golden code, which is conditionally multigroup decodable, the GDL decoder is only about half as complex as the CML decoder."},"body":{"text":"The complexity with which a Space-Time Block Code (STBC) can be maximum-likelihood (ML) decoded is an important parameter from an implementation point of view. Consequently, the problem of designing codes with high rate and good error performance that admit low complexity ML decoding is of much interest in the literature. This problem was ﬁrst attacked by constructing multigroup decodable codes which have the property that the information symbols of the code can be partitioned into several groups, and each group of symbols can be ML decoded independent of other symbol groups. Examples include the Orthogonal Designs [2] and the higher rate multigroup decodable STBCs constructed in [3]\u2013 [8]. In [9], it was shown that a new class of STBCs called fast- decodable or conditionally multigroup decodable codes allow reduced complexity decoding as well. These codes contain a lower rate multigroup decodable STBC as a subcode, and this property is leveraged to decode such STBCs with low complexity. Examples of fast-decodable codes available in the literature include [9]\u2013[13], the Silver code [14], [15] and the Golden Code [16]\u2013[18], [10]. All known low complexity ML decoders have the same uniﬁed approach of exploiting either\nthe multigroup decodability or the conditional multigroup decodability of a code. This method is well known and widely used in the literature, and we will refer to it as Conditional ML (CML) decoding.\nThe Generalized Distributive Law [19] and its equivalent, factor graph based approach, known as the Sum-Product Algorithm [20] are message-passing algorithms that efﬁciently solve a class of computation problems called Marginalize a Product Function (MPF) problems. The Generalized Dis- tributive Law (GDL) includes as special cases the Viterbi\u2019s algorithm, the BCJR algorithm, the Fast-Fourier Transform, the Turbo and LDPC decoding algorithms. In [1], we showed that the ML decoding of any STBC is an MPF problem, and gave a GDL based framework to construct ML decoders for STBCs. We also showed that for two families of STBCs, the Toepltiz codes [21] and the Overlapped Alamouti Codes (OACs) [22], the GDL based ML decoders have strictly less complexity order than the CML decoders. The contribution and organization of this paper are as follows.\n\u2022 We introduce a \u2018traceback\u2019 step to the GDL decoding method of STBCs, which enables roughly 4 times reduc- tion in the complexity of the GDL decoders proposed in [1] (Section III-B).\n\u2022 Using the complexity reduction from the \u2018traceback\u2019 algorithm, we show that the GDL decoding complexity of any STBC, not just the Toeplitz codes and the OACs, is strictly less than the CML decoding complexity (Theo- rem 1, Section III-C). As an application of our results, we show that for any STBC obtained from Cyclic Division Algebras [23] which is not multigroup or conditionally multigroup decodable, the GDL decoder is approximately 12 times less complex than the CML decoder. In case of the Golden code, which is conditionally multigroup decodable, the GDL decoder is roughly half as complex as the CML decoder (Example 3, Section III-D).\n\u2022 When the information symbols of a code are encoded using a PAM signal set, we show that the GDL algorithm can exploit the structure of PAM to lead to further reduction in decoding complexity (Section III-D).\nA brief review of the GDL framework for constructing ML decoders for STBCs [1] is given in Section II.\nThe proofs for all the theorems, propositions and other claims in this paper have been omitted due to space consider- ations, but are available in [24], along with several illustrative\nNotation: Matrices (vectors) are denoted by bold, uppercase (lowercase) letters. The Hermitian and Frobenius norm of a matrix X are denoted by X H and ||X|| respectively. For a square matrix X, tr(X) denotes the trace of X. Unless used as a subscript or to denote indices, j represents\nm × m sized null matrix is denoted by O m . For any set I, its complement in the corresponding universal set is denoted by I c .\nWe consider the n t transmit, n r receive antenna MIMO channel Y = HX + N, where X is the n t × T codeword matrix and N is the complex white Gaussian noise. We assume that H is known at the receiver, but not at the transmitter. We consider STBCs obtained from designs S = K i=1 s i A i . The real symbols s 1 , . . . , s K are partitioned into N encoding groups , x 1 , . . . , x N . The vector x n , consisting of real symbols from the n th encoding group, is encoded by the signal set A n ∈ R λ n , where λ n is the number of symbols in x n . The STBC is thus C = \t K i=1 s i A i x n ∈ A n , n = 1, . . . , N .\ntan −1 (2). The symbols {s i } of this design are encoded independently of each other using a PAM constellation. The number of encoding groups is 8, and each symbol s i forms an encoding group by itself, i.e., x n = [s n ], n = 1, . . . , 8.\ndeﬁned for all i = 1, . . . , K and j > i. For n = 1, . . . , N , let ψ(n) denote the set of indices of those real symbols s i that are in the n th encoding group x n . Then, let α n (x n ) =\ns i s j ξ i,j , and for all 1 ≤ n < m ≤ N , let α n,m (x n , x m ) = i∈ψ(n)\nML solution is the tuple (x 1 , . . . , x N ) that minimizes the global kernel β = N n=1 α n + m>n α n,m , which is equiv- alent to minimizing ||Y − HX|| 2 [1].\nFor \t any \t I = {i 1 , . . . , i |I| } ⊂ {1, . . . , N } \t with i 1 < i 2 < · · · < i |I| , denote by A I the set A i 1 × · · · × A i |I| , and denote by x I the variable list (x i 1 , . . . , x i |I| ). The GDL decoder ﬁnds arg min β(x 1 , . . . , x N ) through a message passing schedule operating on a simple 1 tree G = (V, E). Each vertex v ∈ V is associated with a local kernel α v : A I v → R, and local domain x I v for some I v ⊂ {1, . . . , N }. The tree G must be a junction tree for the STBC C, i.e., it must satisfy: (C.1) for each n = 1, . . . , N , there exists a v ∈ V such that I v = {n}, (C.2) v∈V α v = β, and (C.3) the tree G satisﬁes the junction tree condition, i.e.,\nfor each n = 1, . . . , N , the subgraph of G consisting of those vertices whose local domains contain x n together with the edges connecting these vertices is connected. Note that there is no unique junction tree for a given STBC. A junction tree to decode an arbitrary STBC is shown in Fig. 1. The local kernel at the vertex (x 1 , x 2 , . . . , x N ) at the center is set identically equal to zero, the local kernels at the (x n , x m ) and x n vertices are set to α n,m and α n respectively.\nFor any two neighboring vertices u and v of the junction tree G, the directed message from u to v is a table of values of a function µ u,v : A I u ∩I v → R,\nµ w,u , where w adj u denotes that the vertices w and u are neighbors, and I u \\ I v is the set of elements in I u that are not in I v . The state of the vertex u is a table of values of the function \t σ u (x I u ) = α u (x I u ) + w adj u µ w,u (x I w ∩I u ). To obtain the ML solution (ˆ x 1 , . . . , ˆ x N ), the GDL decoder implements the all-vertex GDL schedule: every vertex is made to send a message to each of its neighbors exactly once, when for the ﬁrst time it receives messages from all its other neighbors. At the end of this schedule, the state of each vertex v is σ v (x I v ) = min x Ic\nβ(x 1 , . . . , x N ). For each n = 1, . . . , N , choose any vertex v with I v = {n}, then the ML solution of x n is ˆ x n = arg min σ v (x n ) [1]. The single-vertex GDL schedule on the other hand computes the ML solution of the variables associated with any one vertex v 0 ∈ V. Here, v 0 is called the root, and every vertex except v 0 sends exactly one message to its neighbor along the unique path to v 0 when it has received messages from all its other neighbors. The state at v 0 at the end of this schedule equals σ v 0 (x I v0 ) = min x Ic\nβ(x 1 , . . . , x N ). The ML solution to x I v0 is then obtained as arg min σ v 0 . The total number of mathematical operations in the case of single-vertex schedule for any root vertex v 0 is equal to C(G) = (w,u)∈E |A I w | + |A I u | − |A I w ∩I u | . The all- vertex GDL schedule can be implemented with complexity of at the most 4C(G) [19]. The complexity order for both single and all-vertex problems is thus max u∈V |A I u |.\nTwo variables x n and x m are said to interfere with each other if there exists a symbol s i in the encoding group x n and a symbol s j in the encoding group x m such that A i A H j + A j A H i = O n t . If no such symbols s i , s j exist we say that x n and x m are non-interfering. The local kernel α n,m (x n , x m ) is identically zero, and hence can be removed from the GDL formulation, for all channel realizations H if and only if x n and x m are non-interfering [1]. The kernels α n , however, are non-zero with probability 1, and can not be removed from the GDL formulation. The existence of such non-interfering symbols can lead to junction trees whose complexity is less than that of the tree in Fig. 1. Thus, all the information required to construct a junction tree for a code is contained in its moral graph , which is a simple graph with vertex set as the variables x n , n = 1, . . . , N , and in which an edge exists between two vertices if and only if the two corresponding variables are interfering. For example, the moral graph of the Golden code is given in Fig. 2.\nIn this section, we introduce the notion of \u2018core\u2019 of a junction tree, and the \u2018traceback\u2019 step in GDL decoding. We then show that GDL has strictly less complexity than CML decoding for any STBC.\nLet T be a simple tree in which every vertex v is associated with a local domain x I v (for some I v ⊂ {1, . . . , N }) and the local kernel α v (x I v ) = 0.\nDeﬁnition 1: The tree T is said to be a core for the STBC C if (i) it satisﬁes the junction tree condition (condition C.3 of Section II), and (ii) for every pair of neighboring vertices (x n , x m ) in the moral graph, there exists a vertex v of T such that {x n , x m } ⊆ x I v .\nFor example, a core for the Golden code is shown in Fig. 3. Given a core T , a junction tree for the STBC can be constructed as follows. For every pair (x n , x m ) of neighboring vertices in the moral graph, choose a vertex v of T such that {x n , x m } ⊆ x I v . If I v = {n, m} then set the local kernel at v to α n,m , else attach a vertex (x n , x m ) with local kernel α n,m to v using a single edge. The set of (x n , x m ) vertices thus added to T form tier 1. Now, for each n = 1, . . . , N , ﬁnd a vertex of tier 1 that contains the variable x n and attach the vertex (x n ) with the local kernel α n to that vertex using a single edge. If there exists no tier 1 vertex that contains x n then connect the (x n ) vertex with local kernel α n to any\nvertex of tier 1 using a single edge. The set of (x n ) vertices thus added form tier 2 of the junction tree.\nThe complexity order of the junction tree thus constructed is determined by the core vertices. Since every pair of interfering symbols must be contained within some \u2018larger\u2019 vertex of the core, the vertex v of the junction tree with the largest |A I v | belongs to the core. Thus, given an STBC/moral graph, the problem of ﬁnding an efﬁcient ML decoder is equivalent to one of constructing a core with the least complexity . There is no unique core for a given STBC/moral graph, and different cores can lead to junction trees with different complexities. For instance, the graph with the single vertex (x 1 , x 2 , . . . , x N ) can always be used as a core irrespective of the structure of the moral graph (see Fig. 1). However this would lead to junction trees with complexity order |A {1,...,N } | = |C|, which is equal to the order of brute-force ML decoding complexity.\nLet G be any junction tree for the STBC C with the encoding groups x 1 , . . . , x N . We will now show that the ML solutions of {x 1 , . . . , x N } can be obtained by running the single-vertex GDL with any vertex v 0 as the root, followed by a traceback step, instead of the all-vertex GDL. This is similar to the Viterbi\u2019s algorithm for decoding convolutional codes, where the actual ML metric of only the last state of the trellis is calculated and then the ML path is traced back to the ﬁrst state. Consider the single-vertex GDL message-passing schedule with v 0 as the root. Every vertex u = v sends a message to its neighbor p(u) on the unique path from u to v 0 , when it has received messages from all its other neighbors. While doing so it computes its partial state λ u (x I u ) = α u (x I u ) + w adj u\nthe message µ u,p(u) (x I u ∩I p(u) ) = min x Iu\\Ip(u) λ u (x I u ). Note that this partial state λ u is different from the state σ u of u at the end of the all-vertex GDL algorithm. These two functions are related as σ u = λ u + µ p(u),u , where µ p(u),u is the message from p(u) to u during the all-vertex GDL. At the end of the single-vertex GDL, v 0 calculates its state σ v 0 , which is equal to min x I c\nβ(x 1 , . . . , x N ). The ML solution to x I v0 is obtained as ˆ x I v0 = arg min σ v 0 (x I v0 ).\nLet u be any vertex such that the ML solution of the local domain of p(u), i.e., ˆ x I p(u) is known. Partition x I u into x A(u) = x I u \\I p(u) and x B(u) = x I u ∩I p(u) . Since the ML solution at p(u) is known, the value ˆ x B(u) that minimizes σ u (x A(u) , x B(u) ) is known. Thus, the ML solution of x A(u) is ˆ x A(u) = arg min x A(u) σ u (x A(u) , ˆ x B(u) )\nHence, the ML solution at u can be obtained merely from λ u and the ML solution at p(u). This is possible since we are only interested in arg min σ u rather than σ u itself. At the end of the single-vertex schedule, the solution at v 0 is ﬁrst found, followed by all its neighbors, and then the neighbors of these vertices, and so on, until the ML solution of all the variables x n , n = 1, . . . , N , are obtained. Since the all-vertex GDL is about four times as complex as the single-vertex GDL, this traceback algorithm provides about 4 times reduction in GDL decoding complexity.\nThe GDL algorithm varies with the choice of the weight matrices, encoding groups and the junction tree. Deﬁne C GDL (C) as the minimum among the complexities (the number of mathematical operations: multiplications, additions and comparisons) of all possible GDL algorithms that can be used to solve the ML decoding problem of C. Similarly for the CML algorithm there can be more than one choice of subcode of C that is multigroup decodable. The complexity of conditional ML decoding then varies with this choice. By C CML (C) is meant the minimum among all possible conditional ML decoding complexities of code C. Almost all STBCs of interest have the property that each encoding group has the same number of real symbols, say t, and the signal set size of all the groups are equal, i.e., |A 1 | = |A 2 | = · · · = |A N |. If the average number of information bits carried by each real symbol is log 2 q then the signal set size |A n | = q t . For the sake of analytical tractability, and considering the widespread prevalence STBCs of this type in the literature, we restrict our analysis of the exact GDL and CML complexities to this class of codes.\nWe say that a code is fully-interfering if all its symbols {x 1 , . . . , x N } are mutually pairwise interfering. For such a code, the CML algorithm performs a brute-force minimization of the ML metric over all q N t values of (s 1 , . . . , s N t ). Its complexity is\nTo GDL decode this STBC, we use the junction tree of Fig. 1. We employ a single-vertex GDL schedule with the root at any one of the (x n , x m ) vertices followed by traceback. The complexity of this GDL decoder is given in (2) at the top of the next page. Comparing the leading terms of (1) and (2), we see that when t = 1, the GDL is about 3 times less complex as the CML. When the symbols are encoded pairwise using a complex constellation, i.e., when t = 2, the GDL is approximately 12 times less complex than the CML decoder. For example, for any STBC obtained from Cyclic Division Algebras [23] that is not multigroup or conditionally multigroup decodable, the GDL decoder gives roughly a 12 times reduction in complexity compared to the CML decoder.\nobtained from a Cyclic Division Algebra [23], where γ = e j 2π 8 , δ is any complex number which is transcendental over the ﬁeld Q( √ γ), and the complex symbols s 2n−1 + js 2n , n = 1, . . . , 4, are encoded using the 8-PSK signal set. This code is fully-interfering, has N = 4, t = 2, q =\n8, and from (1) and (2), its GDL decoder is 19 times less complex than the CML decoder.\nThe GDL decoder is of strictly less complexity not just for full-interfering codes, but for any STBC.\nTheorem 1: Let C be any STBC such that the number of real symbols per each encoding group of C is same, and the signal set size for each of the encoding groups is equal. Then C GDL (C) < C CML (C).\nFor multigroup decodable codes, the GDL decoder ML decodes each group of symbols using a separate junction tree [1]. For conditionally multigroup decodable codes, the junction tree/core is designed intelligently to exploit the fact that certain functions α n,m are identically zero, and this leads to efﬁcient implementations of the ML decoder (see Fig. 3 in Section III-A and Example 3 in Section III-D for an illustration involving the Golden code, which is conditionally multigroup decodable).\nThe structure of the PAM constellation can be exploited to achieve reductions in the CML decoding complexity [10], [12], [15], [18]. In this subsection we show that such a reduction in complexity is possible with GDL as well. Let x n 0 , n 0 ∈ {1, . . . , N }, be any q-ary PAM encoded single real symbol that we wish to remove from the GDL formulation, and N (n 0 ) be the set of indices of those variables that are neighbors of x n 0 in the moral graph. Deﬁne functions\nwhere rnd(·) is the nearest integer function. Then, the ML solution to all the variables other than x n 0 , i.e., that of x {n 0 } c , is arg min β , and can be obtained by the GDL minimization of the function β . The ML solution of x n 0 is the value of ˇ x n 0 corresponding to the optimal x N (n 0 ) . Note that the function h n 0 can be computed with order of complexity |A N (n 0 ) |. Thus, if G = (V, E) is a junction tree for β, and G (V , E ) is a junction tree for β , such that max{max v ∈G |A I v |, |A N (n 0 ) |} < max v∈G |A I v |, then ML decoding the code using the junction tree G provides reduction in the complexity order compared to using the junction tree G.\nLemma 1: If the core T of G has only one vertex containing the variable x n 0 , then the tree T obtained by removing x n 0 from this vertex of T is a core for GDL minimization of β .\nThis technique of removing a PAM encoded variable can be generalized to any set R ⊆ {1, . . . , N } of variables that satisﬁes the condition given in Lemma 2 below. In this case, the variables x n , n ∈ R, are removed one by one from the GDL formulation, in an arbitrary order, using the same technique as above.\nLemma 2: The PAM encoded set of variables x R can be removed from the GDL formulation using scaling and hard- limiting if and only if the subgraph of the moral graph generated by these variables is edgeless.\nExample 3: Consider the junction tree core T for the Golden code shown in Fig. 3. From Lemma 2 and the moral graph of the Golden code given in Fig. 2, we see that the variables x 1 and x 2 can be removed using scaling and hard-limiting. Using Lemma 1 we get the junction tree core T shown in Fig. 4. The removal of the variables x 1 and x 2 has enabled the reduction of the GDL complexity order from q 6 to q 5 . The total number of mathematical operations involved in the GDL decoding of the Golden code using T is 42q 5 + 6q 4 + 21q 2 + 52q − 5. The CML decoder [10], [18], on the other hand, involves 76q 5 + 43q 4 − 1 operations. Comparing the leading order terms, we see that the GDL decoder is about 1.8 times as fast as the CML decoder. For instance, when q = 2 or 4 (corresponding to the rates 4 and 8 bits per channel use), the GDL decoder gives a complexity reduction of 1.9 compared to the CML decoding algorithm.\nThis work was supported partly by the DRDO-IISc program on Advanced Research in Mathematical Engineering through a research grant, and partly by the INAE Chair Professorship grant to B. S. Rajan. The authors thank K. Pavan Srinath for useful discussions on this subject."},"refs":[{"authors":[{"name":"L. P. Natarajan"},{"name":"K. P. Srinath"},{"name":"B. S Rajan"}],"title":{"text":"Generalized Distributive Law for ML Decoding of STBCs"}},{"authors":[{"name":"V. Tarokh"},{"name":"H. Jafarkhani"},{"name":"A. R. Calderbank"}],"title":{"text":"Space-Time Block Codes from Orthogonal Designs"}},{"authors":[{"name":"C. Yuen"},{"name":"Y. L. Guan"},{"name":"T. T. Tjhung"}],"title":{"text":"Quasi-Orthogonal STBC with Minimum Decoding Complexity"}},{"authors":[{"name":"H. Jafarkhani"}],"title":{"text":"A Quasi-Orthogonal Space-Time Block Code"}},{"authors":[{"name":"W. Su"},{"name":"X.-G. Xia"}],"title":{"text":"Signal Constellations for Quasi-Orthogonal Space- Time Block Codes with Full-Diversity"}},{"authors":[{"name":"Z. A. Khan"},{"name":"B. S. Rajan"}],"title":{"text":"Single Symbol Maximum Likelihood Decodable Linear STBCs"}},{"authors":[{"name":"D. N. Dao"},{"name":"C. Yuen"},{"name":"C. Tellambura"},{"name":"Y. L. Guan"},{"name":"T. T. Tjhung"}],"title":{"text":"Four-Group Decodable Space-Time Block Codes"}},{"authors":[{"name":"S. Karmakar"},{"name":"B. S. Rajan"}],"title":{"text":"Multigroup-Decodable STBCs from Clifford Algebras"}},{"authors":[{"name":"E. Biglieri"},{"name":"Y. Hong"},{"name":"E. Viterbo"}],"title":{"text":"On Fast-Decodable Space-Time Block Codes"}},{"authors":[{"name":"K. P. Srinath"},{"name":"B. S. Rajan"}],"title":{"text":"Low ML-Decoding Complexity, Large Coding Gain, Full-Rate, Full-Diversity STBCs for 2x2 and 4x2 MIMO Systems"}},{"authors":[{"name":"M. Sinnokrot"},{"name":"J. R. Barry"},{"name":"V. Madisetti"}],"title":{"text":"Embedded Alamouti Space-Time Codes for High Rate and Low Decoding Complexity"}},{"authors":[{"name":"S. Sirianunpiboon"},{"name":"Y. Wu"},{"name":"A. R. Calderbank"},{"name":"S. D. Howard"}],"title":{"text":"Fast optimal decoding of multiplexed orthogonal designs"}},{"authors":[{"name":"F. Oggier"},{"name":"R. Vehkalahti"},{"name":"C. Hollanti"}],"title":{"text":"Fast-decodable MIDO Codes from Crossed Product Algebras"}},{"authors":[{"name":"A. Hottinen"},{"name":"O. Tirkkonen"},{"name":"R. Wichman"}],"title":{"text":"Multi-antenna Transceiver Techniques for 3G and Beyond"}},{"authors":[{"name":"J. Paredes"},{"name":"B. Gershman"},{"name":"M. Gharavi-Alkhansari"}],"title":{"text":"A New Full-Rate Full-Diversity Space-Time Block Code With Nonvanishing Determinants and Simpliﬁed Maximum-Likelihood Decoding"}},{"authors":[{"name":"J. C. Belﬁore"},{"name":"G. Rekaya"},{"name":"E. Viterbo"}],"title":{"text":"The Golden Code: A 2 × 2 full rate space-time code with non-vanishing determinants"}},{"authors":[{"name":"P. Dayal"},{"name":"M. K. Varanasi"}],"title":{"text":"An Optimal Two transmit antenna Space- Time Code and its Stacked Extensions"}},{"authors":[{"name":"M. O. Sinnokrot"},{"name":"J. Barry"}],"title":{"text":"Fast Maximum-Likelihood Decoding of the Golden Code"}},{"authors":[{"name":"S. M. Aji"},{"name":"R. J. McEliece"}],"title":{"text":"The Generalized Distributive Law"}},{"authors":[{"name":"F. R. Kschischang"},{"name":"B. J. Frey"},{"name":"H.-A. Loeliger"}],"title":{"text":"Factor graphs and the sum-product algorithm"}},{"authors":[{"name":"J.-K. Zhang"},{"name":"J. Liu"},{"name":"K. M. Wong"}],"title":{"text":"Linear Toeplitz space time block codes"}},{"authors":[{"name":"Y. Shang"},{"name":"X.-G. Xia"}],"title":{"text":"Space-time block codes achieving full diversity with linear receivers"}},{"authors":[{"name":"B. A. Sethuraman"},{"name":"B. S. Rajan"},{"name":"V. Shashidhar"}],"title":{"text":"Full-diversity, High- rate Space-Time Block Codes from Division Algebras"}},{"authors":[{"name":"L. P. Natarajan"},{"name":"B. S. Rajan"}],"title":{"text":"Generalized Distributive Law for ML Decoding of Space-Time Block Codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569558697.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S15.T3.1","endtime":"10:10","authors":"Lakshmi Prasad Natarajan, B. Sundar Rajan","date":"1341568200000","papertitle":"Generalized Distributive Law for ML Decoding of STBCs: Further Results","starttime":"09:50","session":"S15.T3: Topics in MIMO","room":"Stratton S. de P. Rico (202)","paperid":"1569558697"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
