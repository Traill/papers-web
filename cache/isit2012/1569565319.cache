{"id":"1569565319","paper":{"title":{"text":"String reconciliation with unknown edit distance"},"authors":[{"name":"Aryeh (Leonid) Kontorovich"},{"name":"Ari Trachtenberg"}],"abstr":{"text":"Abstract\u2014We consider the problem of reconciling two remote strings of arbitrary and unknown similarity using minimum communication, which is at the core of some important problems in networking, cryptography, genetic engineering, and even linguistics. Though this problem is efﬁciently convertible into a set reconciliation instance, for which efﬁcient solutions exist, this conversion may introduce ambiguity in the decoding process, which may require signiﬁcant communication and computational resources to resolve. We leverage some recent advances in efﬁcient unique decodability of strings to reduce decoding ambiguity, and thus pave the way for a practical implementation of this string reconciler. For certain random strings and in some ideal cases, our approach reconciles two length n strings that differ in α edits (with α not known a priori) using O α log 2 (n) communication."},"body":{"text":"The problem of efﬁciently reconciling similar strings is fundamental to a variety of problems. Within a biologi- cal context, this problem is related to sequencing of DNA from short reads [5] and reconstruction of protein sequences from K-peptides [22]. Communications protocols [1, 3] at- tempt to identify differences between related documents using string reconciliation, and fuzzy extractors [8] employ similar techniques to match noise-prone biometric data to baseline measurements in a cryptographically secure fashion. Even computational linguistics uses related approaches to learn transformations on varying-length sequences [21].\nOur approach extends and, in many ways makes prac- tical, the protocol in [1], which effectively translates the edit distance problem into a set reconciliation problem. The transformation is accomplished through the use of shingling [3, 4], wherein a string is divided into overlapping substrings (called shingles). Two remote strings are thus reduced to sets of shingles, which can be reconciled efﬁciently using existing approaches (e.g. [16, 17]).\nOnce a remote string\u2019s shingle set is known, the shingles can be pieced together to determine the remote string. The problem is that, in general, there may be a large number of possible string reconstructions from a given collection of shingles, equal to the number of Eulerian cycles in the corresponding de Bruijn graph. For example, the shingles\nThe work in [1] proposed two solutions to the reconstruction ambiguity. The ﬁrst involves enumerating all (possibly expo- nentially many) Eulerian cycles in the graph, and transmitting the index of the cycle producing the desired string; this can require signiﬁcant computational resources and may incur an additional communication cost superlinear in the number of shingles. An alternate solution in the same work shows that if all shingles are of a certain minimal length, roughly loga- rithmic in string length, then there is likely just one possible reconstruction; that solution views strings unrealistically as independent and identically distributed (iid) bits, and it also only gives a probabilistic assurance of unique reconstruction.\nIn this work, we propose a third solution based on the theory of uniquely decodable strings, wherein we efﬁciently tailor the shingles so as to guarantee exactly one possible reconstruction. B. Outline\nWe begin in Section II with an overview of related work from the information theory and theoretical computer science communities, followed in Section III by a technical exposition of the existing approach to string reconciliation on which this work is based. Section IV summarizes relevant work in [13] for efﬁciently determining whether a string has a unique decoding. Our new string reconciliation protocol based upon an automaton for detecting unique decodability is described in Section V. We close with concluding remarks in Section VI.\n1) Edit distance: The problem of determining the minimum number of edits (insertions or deletions) required to transform one string into another has a long history in the literature [6, 11]. Orlitsky [18] shows that amount of communication C ˆ α (x, y) needed to reconcile two strings x and y (of lengths |x| and |y| respectively) that are known to be at most ˆα-edits apart is at most\nalthough he leaves an efﬁcient one-way protocol as an open question.\nThe literature includes a variety of proposed protocols for this problem. Cormode et al. [7] propose a hash-based approach that requires a known bound ˆ α on edits between x and y (assuming, without loss of generality, that y is the longer string) and communicates at most\nOrlitsky and Viswanthan [19] propose a interactive protocol that does not need to know the number of edits in advance and requires at most\nOther approaches include those of Evﬁmievski [10] for small edit distances, Suel [23] based on delta-compression, and Tridgell [24] which presents the computationally efﬁcient (but potentially communicationally inefﬁcient) rsync protocol.\n2) Unique Decoding: It was shown in [14] that the collec- tion of strings having a unique reconstruction from the shingles representation is a regular language. An explicit construction of a deterministic ﬁnite-state automaton (DFA) recognizing this language was given in by Li and Xie [15]. Unfortunately, for an input alphabet Σ, this DFA has\nstates, and thus does not seem practical except for very small alphabets.\nOur work in [13], brieﬂy summarized in Section IV for sake of completeness, has demonstrated that there is no DFA of subexponential size for recognizing this language, and, instead, exhibited an equivalent NFA with O( |Σ| 3 ) states, which we shall utilize in this paper.\nThere has also been work on the probability of a collection of shingles having a unique reconstruction. The authors in [1] show that we can expect a unique decoding for substrings of identically distributed, independent random bits as long as the substrings are roughly logarithmic in the size of the overall decoded string (a precise statement is provided in Section V).\nThe work in [9] also provides evidence of a high probability of unique decoding for logarithmically sized substrings, and includes generalizations to non-binary and even non-uniformly random characters for the strings. This is extended in [2] to categorize the number of decodings for a given collection of shingles, and [20] considers decoding from regularly gapped collections of substrings in a DNA sequencing framework.\nWe next present the string reconciliation approach in [1], which is based on a transformation to an instance of the set reconciliation [17].\nThe problem of set reconciliation seeks to reconcile two remote sets S A and S B of b-bit integers using minimum communication. The approach in [17] involves translating set elements into an equivalent characteristic polynomial, so that the process of set reconciliation is translated into an equivalent problem of rational function interpolation, similar to Reed- Solomon decoding.\nThe resulting algorithm requires one message of roughly bm bits of communication and bm 3 computation to reconcile two sets that differ in m entries. As such, two sets of a billion 32-bit integer that differ in three integers can be reconciled with roughly 96 bits of communication. The approach can be improved to expected bm communication and computation through the use of interaction [16] and generalized to multisets (straightforwardly) and arbitrary error-correcting codes [12].\nA string σ can be transformed into a multiset S through shingling, or collecting all contiguous substrings of a given length. For example, shingling the string katana into size 2 shingles produces the multiset in (1). As such, in order to reconcile two strings σ A and σ B , the protocol STRING- RECON ﬁrst shingles each string, then reconciles the resulting sets, and then puts the shingles back together into strings in order to complete the reconciliation. It is important to note that if two strings differ by α edits, then they will also differ in O(α) shingles, as long as shingle size is a constant.\nThe process of putting shingles of length l back into a string involves the construction of a modiﬁed de Bruijn graph of the shingles. In this graph, each shingle corresponds to an edge, with weight equal to the number times the shingle occurs in the multiset. The vertices of the graph are all length l − 1 substrings over the shingling alphabet; in this manner, an edge e(u, v) corresponds to a shingle s if u (resp. v) is a preﬁx (resp. sufﬁx) of s. A special character $ used at the beginning and end of the string in order to mark the ﬁrst and last shingle.\nAn Eulerian cycle in the modiﬁed de Bruijn graph, starting at the ﬁrst shingle, necessarily corresponds to a string that is consistent with the set of shingles. Unfortunately, there may be a large number of such strings, requiring either the enumeration of a speciﬁc cycle of interest or another way to guarantee only one possible cycle.\nOur string reconciliation approach hinges upon the ability to efﬁciently discern whether a string is uniquely decodable from its shingles. To this end, we next summarize the relevant work in [13] for the explicit construction of a deterministic ﬁnite- state automaton (DFA) recognizing exactly such strings, and an equivalent, but more efﬁcient non-deterministic ﬁnite-state automaton (NFA).\nWe assume a ﬁnite alphabet Σ along with a special delimiter character $ / ∈ Σ, and deﬁne Σ $ = Σ ∪ {$}. For k ≥ 1, the k- gram map Φ takes string x ∈ $Σ ∗ $ to a vector ξ ∈ N Σ k $ , where\nξ i 1 ,...,i k ∈ N is the number of times the string i 1 . . . i k ∈ Σ k occurred in x as a contiguous subsequence, counting overlaps. Note that, though we focus this section on the bigram case when k = 2, we will subsequently employ these results for the general case k > 2.\nAs we have seen in the introduction, the bigram map Φ : $Σ ∗ $ → N Σ 2 $ is not injective; for example, Φ($ katana$) = Φ($kanata$).\nWe denote by L UNIQ ⊆ Σ ∗ the collection of all strings w for which\nsymbol from the alphabet by Σ ¯ x := Σ \\ {x} for x ∈ Σ. B. Construction and simulation of the NFA\nI x,a,b = L (Σ ∗ axΣ ∗ ¯ a bΣ ∗ ) and\nwhose elements are called obstructions. The language of all obstructions is thus\nThe work in [13] provides a canonical DFA that recognizes K x,a,b with 9 states, regardless of Σ. Over all x ∈ Σ and a, b ∈ Σ ¯ x , there are\n|Σ| (|Σ| − 1 + (|Σ| − 1)(|Σ| − 2)) \t (4) distinct obstruction languages, whose union can thus be ac- cepted by an NFA of O( |Σ| 3 ) states.\nThe main theorem is thus that the language of obstructions is precisely the complement of the language of uniquely decodable strings.\nThe result of Theorem 1 is that the NFA accepting K x,a,b \u2019s can be used to efﬁciently test for unique decodability.\nWe next propose the main protocol of our paper for string reconciliation, as an amalgam of Section III and the work in [13], presented as a high-level description in Protocol 1.\n1. Split σ into a set S σ of length l shingles, with the i-th shingle of the string denoted s i . Similarly split τ into S τ .\n4. For i from 1 to |σ| − l + 1 do S i σ ←− S i−1 σ ∪ {s i }\nMerge the last two shingles added to S i σ . 5. Exchange indices of merged shingles.\nOur protocol is fundamentally based on the concept of a shingling, as used in Section III. Recall that a shingle s = s 1 s 2 . . . s k is simply an element of Σ ∗ $ . For two shingles s = s 1 s 2 . . . s k and t = t 1 t 2 . . . t , we write s l t if there is some length ≥ l sufﬁx u of s that is also a preﬁx of t, or, more precisely, if we can rewrite s = s u and t = ut\nfor strings s , t and |u| ≥ l. We deﬁne the non-overlapping concatenation s t as the concatenation s ut , where s = s u, t = ut and |u| = l − 1. For example, kata 3 tana and kata tana = katana.\nFor a ﬁxed l, the sequence of shingles s 1 l s 2 l . . . l s t is said to represent the word w ∈ Σ ∗ if w = s 1 s 2 . . . s t and s i l s i+1 for all i. If S = s 1 , . . . , s t is a multiset of shingles, we will use Φ −1 (S) ⊂ Σ ∗ to denote the collection of all words represented by S. More formally, deﬁne Π = Π(S) to be the set of all permutations on t = |S| elements with the property that s π(i) l s π(i+1) for all i. Then Φ −1 (S) is\nWe refer to the members of Φ −1 (S) as the decodings of S, and say that S is uniquely decodable if |Φ −1 (S)| = 1.\nAn shingling I of a word w = w 1 . . . w t ∈ Σ ∗ is a set of substrings of w that represents w. We say that I is an uniquely decodable shingling of w if |Φ −1 (I(w))| = 1.\nAs a simple example, consider the string w = katana with the shingling I(w) = {$k, ka, at, ta, an, na, n$}. As we saw in the introduction, for l=2, I can be alternately decoded into kanata and is thus not uniquely decodable. However, if the second and third shingles are merged into ata, that the shingling becomes {$k, ka, ata, an, na, n$}, and then there is exactly one decoding: katana.\nProtocol 1 transforms a string that is not uniquely decodable into one that is by merging shingles. Several important details of Protocol 1 require explanation and proof of correctness.\n1) Steps 1 and 2: The ﬁrst two steps of the protocol derive from the base protocol described in Section III. Note that l is an implementation parameter.\n2) Step 3: The expression S i σ represents the multiset of shingles that have been seen so far. It is modiﬁed, by com- bining shingles as necessary in the subsequent steps, in order to ensure unique decodability. If full reconciliation is desired (i.e. both hosts know the other host\u2019s string, as opposed to just one host having this knowledge) then Steps 3 and 4 are similarly run on the remote host with set S i τ .\n3) Step 4: In merging two shingles s a and s b , we are simply computing the non-overlapping concatenation s a := s a s b , as deﬁned earlier. Since the shingles are contiguous and based on an initial length l shingling, we know necessarily that s a l s b . Furthermore, it is clear that such merging will always, eventually, lead to a decodable set of shingles because, at worst, the protocol results in just one shingle representing the entire string, which is necessarily uniquely decodable.\nThe main challenge of this step is in checking whether a given set of shingles is uniquely decodable. This can be done by considering the de Bruijn graph of the shingles. The vertices of this graph are the length l − 1 preﬁxes and sufﬁxes of the shingles, and the edges correspond directly to shingles, as described in Section III. Clearly a given set of shingles is uniquely decodable iff there is a unique Eulerian cycle through this graph. At the same point, if we were to relabel all vertices with distinct characters over a ﬁctitious alphabet Σ of cardinality S, then we can view the graph as a bigram graph over Σ . In other words, determining the unique decodability of the shingle set is equivalent to determining the unique decodability of a string corresponding to an arbitrary Eulerian path in the graph, and this can be tested using the machinery described in Section IV.\n4) Step 5: Each host needs to know which shingles were merged on the other host in order to produce a uniquely decodable multiset of shingles. Since each merge involves at least one shingle of length l, it sufﬁces to exchange a list of indices of length l shingles that are involved in a merge. The index can be chosen canonically from an alphabetically ordered list of all shingles.\noperations as possible, since, at worst, every shingle is merged in this step, requiring n log n bits of communication for a shingle set of size n. In the best case, no shingles are merged and the communication complexity of the protocol is directly related to the edit distance between reconciled strings.\nThough it is hard to give precise bounds on the number of shingles that are merged in this step, the work in [1] provides some guidance for random strings. Speciﬁcally, for strings of n random bits, in which each bit is 0 with probability p > 0.5, then we can expect each node in the de Bruijn graph of length l shingles to have only one outgoing edge (implying unique decodability) if\nwhere W ( ·) is the Lambert W function. When n goes to inﬁn- ity, then (5) is O(log(n)), meaning that logarithmically sized shingles should avoid communicationally expensive merges.\n5) Step 6: The resulting collection of shingles can only be decoded in one way, which can be provided by any efﬁcient algorithm for generating an Eulerian cycle through the graph.\nConsider two remote hosts, one with the string σ = katana and the other with the string τ = kanatas. In Step 1 of the protocol, the two hosts produce the set of length l = 2 shingles\nIn Step 2, both hosts utilize a set-reconciliation protocol to reconcile their shingle sets. At the end of this step, the ﬁrst host knows S τ and the second host knows S σ .\nIn Step 3, the ﬁrst host sets S 0 σ = {$k}, corresponding to its ﬁrst shingle. Then, in Step 4, the host extends this until it\nreaches a non-uniquely decodable multiset: S 1 σ = {$k, ka}\nTo notice that S 5 σ is not uniquely decodable, the host considers the de Bruijn graph in Figure 1 and runs the NFA described in Section IV on the corresponding alphabet {$, k, a, t, n} for the preﬁx $katana formed from an arbitrary Eulerian path through the graph (starting at $).\nCorrecting the non-unique decodability of S 5 σ involves merging shingles an and na into ana, and then again with shingle ta into tana. The resulting shingles\nare uniquely decodable, and Step 4 continues without further merges to produce\nIn Step 5, the host must communicate the fact that it had merged an and na into the shingle ana, and then merged ta into ana to get tana. This involves transmitting the indices of an and ta in the alphabetical ordering of S σ :\nFinally, the remote host produces a de Bruijn graph of the shingle set S 6 σ , with vertices corresponding to a length l −1 = 1 preﬁx and sufﬁx of each shingle, as in Figure 2. There is only one decoding of this de Bruijn graph, namely the string $ katana$.\nFor two strings of length n differing in α edits, Step 2 will require O(α l 2 ) bits of communication for the implementation parameter l. Step 5 will require between 0 and n log(n −l+1) communication, depending on the decodability of the string.\nWhen the two strings are composed of random iid bits, then, under the appropriate choice of l from (5), we can expect that no merging is needed giving an overall communication complexity that is O α log 2 (n) , for large n.\nWe have provided a novel algorithm for string reconciliation by combining an existing approach based on transformation to set reconciliation with an efﬁcient means for testing the unique decodability of a string. In the best case and in certain random cases, our approach provides a computationally efﬁcient and nearly communicationally optimal protocol for string recon- ciliation, although we leave open a precise categorization of when or how often this best case appears in practical situations."},"refs":[{"authors":[],"title":{"text":"Sachin Agarwal, Vikas Chauhan, and Ari Trachtenberg"}},{"authors":[{"name":"B. Sorkin"}],"title":{"text":"Richard Arratia, B´ela Bollob´as, Don Coppersmith, and Gregory  Euler circuits and dna sequencing by hybridization"}},{"authors":[{"name":"A. Broder"}],"title":{"text":"On the resemblance and containment of documents"}},{"authors":[{"name":"Z. Brode"},{"name":"M. Friez"}],"title":{"text":"Andrei  Moses Charikar, Alan  and Michael Mitzen- macher"}},{"authors":[{"name":"A. Pevzne"}],"title":{"text":"Mark Chaisson, Pavel  and Haixu Tang"}},{"authors":[{"name":"H. Corme"},{"name":"E. Leiserso"},{"name":"L. Rives"},{"name":"F. Stein"}],"title":{"text":"T"}},{"authors":[{"name":"G. Cormod"},{"name":"M. Paterso"},{"name":"C. Sahinal"},{"name":"U. Vishkin"}],"title":{"text":"S"}},{"authors":[{"name":"J. Comput"}],"title":{"text":"Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin, and Adam Smith"}},{"authors":[],"title":{"text":"Martin Dyer, Alan Frieze, and Stephen Suen"}},{"authors":[{"name":"V. Evﬁmievski"}],"title":{"text":"A"}},{"authors":[],"title":{"text":"Dan Gusﬁeld"}},{"authors":[{"name":"M. Karpovsk"},{"name":"L. Leviti"},{"name":"A. Trachtenberg"}],"title":{"text":"Data veriﬁcation and reconciliation with generalized error-control codes"}},{"authors":[],"title":{"text":"Aryeh (Leonid) Kontorovich and Ari Trachtenberg"}},{"authors":[],"title":{"text":"Leonid Kontorovich"}},{"authors":[{"name":"J. Comput"}],"title":{"text":"Qiang Li and Huimin Xie"}},{"authors":[{"name":"Y. Minsk"},{"name":"A. Trachtenberg"}],"title":{"text":"Scalable set reconciliation"}},{"authors":[{"name":"Y. Minsk"},{"name":"A. Trachtenber"},{"name":"R. Zippel"}],"title":{"text":"Set reconciliation with nearly optimal communication complexity"}},{"authors":[{"name":"A. Orlitsky"}],"title":{"text":"Interactive communication: Balanced distributions, corre- lated ﬁles, and average-case complexity"}},{"authors":[{"name":"A. Orlitsk"},{"name":"K. Viswanathan"}],"title":{"text":"Practical protocols for interactive communication"}},{"authors":[{"name":"P. Preparat"}],"title":{"text":"Franco  Eli Upfal"}},{"authors":[{"name":"D. E. Rumelhar"},{"name":"J. L. McClelland"}],"title":{"text":"On learning past tenses of english verbs"}},{"authors":[],"title":{"text":"Xiaoli Shi, Huimin Xie, Shuyu Zhang, and Bailin Hao"}},{"authors":[],"title":{"text":"Torsten Suel, Patrick Noel, and Dimitre Trendaﬁlov"}},{"authors":[{"name":"A. Tridgell"}],"title":{"text":"Efﬁcient algorithms for sorting and synchronization"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565319.pdf"},"links":[{"id":"1569564843","weight":2},{"id":"1569566385","weight":3},{"id":"1569566875","weight":5},{"id":"1569564605","weight":4},{"id":"1569566855","weight":2},{"id":"1569565551","weight":2},{"id":"1569565711","weight":2},{"id":"1569566415","weight":2},{"id":"1569566081","weight":2},{"id":"1569565547","weight":4},{"id":"1569565461","weight":2},{"id":"1569564233","weight":2},{"id":"1569563411","weight":4},{"id":"1569564401","weight":7},{"id":"1569564203","weight":2},{"id":"1569560613","weight":4},{"id":"1569566999","weight":2},{"id":"1569566563","weight":2},{"id":"1569564387","weight":2},{"id":"1569566497","weight":2},{"id":"1569566795","weight":2},{"id":"1569566889","weight":3},{"id":"1569566269","weight":2},{"id":"1569566343","weight":8},{"id":"1569566679","weight":2},{"id":"1569566575","weight":2},{"id":"1569563981","weight":2},{"id":"1569563307","weight":2},{"id":"1569566657","weight":2},{"id":"1569565199","weight":2},{"id":"1569565833","weight":3},{"id":"1569565667","weight":8},{"id":"1569561795","weight":11},{"id":"1569559805","weight":2},{"id":"1569559111","weight":2},{"id":"1569566939","weight":2},{"id":"1569564209","weight":25},{"id":"1569565151","weight":3},{"id":"1569563763","weight":2},{"id":"1569566473","weight":2},{"id":"1569565033","weight":3},{"id":"1569566141","weight":2},{"id":"1569555879","weight":2},{"id":"1569566115","weight":2},{"id":"1569565219","weight":2},{"id":"1569565029","weight":3},{"id":"1569565393","weight":4},{"id":"1569567033","weight":2},{"id":"1569567029","weight":5},{"id":"1569561123","weight":2},{"id":"1569566893","weight":2},{"id":"1569566317","weight":2},{"id":"1569565439","weight":2},{"id":"1569562551","weight":2},{"id":"1569566155","weight":2},{"id":"1569564411","weight":3},{"id":"1569566831","weight":2},{"id":"1569566873","weight":2},{"id":"1569565765","weight":2},{"id":"1569565925","weight":3},{"id":"1569565919","weight":2},{"id":"1569566711","weight":2},{"id":"1569565241","weight":2},{"id":"1569564919","weight":2},{"id":"1569566737","weight":2},{"id":"1569566917","weight":2},{"id":"1569565353","weight":2},{"id":"1569564683","weight":11},{"id":"1569564305","weight":2},{"id":"1569564291","weight":4},{"id":"1569565421","weight":7},{"id":"1569566651","weight":2},{"id":"1569566595","weight":8},{"id":"1569566529","weight":2},{"id":"1569562277","weight":2},{"id":"1569564437","weight":3},{"id":"1569551905","weight":3},{"id":"1569565529","weight":3},{"id":"1569561185","weight":2},{"id":"1569565769","weight":2},{"id":"1569563919","weight":2},{"id":"1569565997","weight":2},{"id":"1569565035","weight":2},{"id":"1569564961","weight":2},{"id":"1569565853","weight":2},{"id":"1569564123","weight":2},{"id":"1569564505","weight":2},{"id":"1569565635","weight":4},{"id":"1569566797","weight":2},{"id":"1569566555","weight":2},{"id":"1569565373","weight":2},{"id":"1569566973","weight":2},{"id":"1569565139","weight":2},{"id":"1569566727","weight":2},{"id":"1569560581","weight":3}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S15.T9.3","endtime":"10:50","authors":"Aryeh Kontorovich, Ari Trachtenberg","date":"1341570600000","papertitle":"String reconciliation with unknown edit distance","starttime":"10:30","session":"S15.T9: Strings, Sorting, and Biology","room":"Stratton West Lounge (201)","paperid":"1569565319"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral14":"13","spectral20":"14","spectral9":"8","spectral3":"1","spectral17":"2","louvain":"597","spectral10":"2","spectral15":"5","spectral5":"4","spectral8":"2","spectral11":"10","spectral4":"2","spectral12":"7","spectral19":"13","spectral7":"5","spectral13":"1","spectral18":"9","spectral2":"0","spectral16":"5"}}
