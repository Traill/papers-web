{"id":"1569565369","paper":{"title":{"text":"On the Query Computation and Veriﬁcation of Functions"},"authors":[{"name":"Hirakendu Das Ashkan Jafarpour Alon Orlitsky Shengjun Pan Ananda Theertha Suresh"}],"abstr":{"text":"Abstract\u2014In the query model of multi-variate function compu- tation, the values of the variables are queried sequentially, in an order that may depend on previously revealed values, until the function\u2019s value can be determined. The function\u2019s computation query complexity is the lowest expected number of queries required by any query order. Instead of computation, it is often easier to consider veriﬁcation, where the value of the function is given and the queries aim to verify it. The lowest expected number of queries necessary is the function\u2019s veriﬁcation query complexity. We show that for all symmetric functions of indepen- dent binary random variables, the computation and veriﬁcation complexities coincide. This provides a simple method for ﬁnding the query complexity and the optimal query order for computing many functions. We also show that if the symmetry condition is removed, there are functions whose veriﬁcation complexity is strictly lower than their computation complexity, and mention that the same holds when the independence or binary conditions are removed."},"body":{"text":"The worst-case query complexity or decision-tree complex- ity [2, 3, 4, 5, 8] of a multi-variate function is the number of function inputs that must be queried in the worst case to determine the function\u2019s value. For example, the worst-case query complexity of xy ∨ xz is 2, as the value of x determines which of y or z needs to be queried to determine the function\u2019s value.\nA multi-variate function is symmetric if its output remains unchanged under all input permutations. Many functions en- countered in engineering and science are symmetric, including parity , threshold, and delta, as well as most statistical mea- sures such as median, mode, max, and order statistics. Essen- tially all results in this paper concern symmetric functions.\nIt is easy to see, e.g. [6], that the worst-case query complex- ity of all non-constant symmetric functions is n. Kowshik and Kumar [7] recently considered the expected query complexity of computing symmetric functions. For expected complexity, the optimal query order depends not only on the function, but also on the underlying distribution. They found an optimal query order for threshold functions of independent Ber(p i ) random variables. In particular, they showed that for these functions the optimal query order does not depend on the precise probabilities p i , but only on which is largest, second largest, etc.\nTo simplify and extend arguments for ﬁnding the optimal query order, [1] deﬁned the expected veriﬁcation query com- plexity of a function to be the lowest expected number of inputs that need to be revealed to convince an observer of the\nvalue of the function. For example, consider the OR function X 1 ∨ . . . ∨ X n , where each X i ∼ Ber(p i ) independently of each other. To verify that the OR is 1, it sufﬁces to show that one of the X i \u2019s is 1, hence for moderate values of the p i \u2019s, the expected number of variables that need to be revealed is small, whereas verifying that the OR is 0, requires checking that all variables are 0, hence all n variables must always be queried. Note that veriﬁcation complexity differs from certiﬁcate complexity [5, 2], where all input values are known in advance and can be used to determine the optimal query order.\nVeriﬁcation complexity was used in [1] to provide a simpler proof that the query order for computing threshold functions presented in [7] is optimal, to derive an optimal query order for computing delta functions, and, observing that the value of all binary-input symmetric functions depends only on the number of ones or weight of the input, to ﬁnd an optimal query order for symmetric functions that vary over any three consecutive input weights.\nIn this paper, we extend the results in [1] and show that for all symmetric functions of independent binary inputs, optimal expected veriﬁcation and computation complexity are equal. The symmetry, independence, and binary conditions are necessary in the sense that if any of them is relaxed then there are functions whose expected veriﬁcation complexity is strictly lower than their expected computation complexity.\nThe rest of the paper is organized as follows. In Section II, we formally deﬁne the problem of computation and veriﬁca- tion. In Section IV, we show the equality of veriﬁcation and computation for general symmetric functions of independent binary inputs. In Section V, we give an example of a non- symmetric function of independent binary inputs where the veriﬁcation and computation complexities differ. Similar ex- amples showing that the independence and binary assumptions are necessary will be provided in the paper\u2019s full version.\nThroughout the paper, we assume that f is a symmetric function of n independent binary random variables X 1 , X 2 , . . . , X n , where X i ∼ Ber(p i ) and the p i \u2019s are known in advance, and without loss of generality, 1 > p 1 ≥ p 2 ≥ . . . ≥ p n > 0. We also let ¯ p i def = 1 − p i and X j def = X 1 , . . . , X j .\nTo compute f (x n ), we query the inputs sequentially. A policy P is a rule that at any given time, based on prior\nquery outcomes, determines whether querying should stop or continue, and in the latter case, which input should be queried next. Once an input is queried, its full value is revealed. P computes f , if for all x n , when P stops querying, f can be determined.\nLet N (x n ) be the number of inputs a policy P queries for input x n . The expected query complexity of P is\nwhere the minimum is taken over all policies computing f . Any policy for f with complexity C(f ) is called optimal. In general, there might be several optimal policies.\nand let f (X 1 , X 2 ) = Π 1 (X 1 + X 2 ). If X i is queried ﬁrst, the expected number of queries is 1 · p i + 2 · (1 − p i ) = 2 − p i . Since we assume p 1 ≥ p 2 , the policy querying X 1 ﬁrst is always optimal.\nFor general functions, it is possible to express the computa- tion complexity in terms of the input probabilities and optimize the query order. But since the possible number of policies is exponential in n, the problem may not be easy to solve for all functions.\nAn alternative approach for this problem was proposed in [1]. Instead of ﬁnding the optimal policy for computing a function, the simpler problem of ﬁnding an optimal policy for verifying the function\u2019s value was considered. It was shown that for a class of functions, the two policies coincide.\nIn the veriﬁcation of a function f , we are given the value of f (x n ), and are asked to query the inputs to verify that this is indeed the function\u2019s value. As with computation, we apply a policy that determines which input variable to query and when to stop, the value of the function can be determined. But the difference is that now we can use different policies based on the value of f (x n ). It is therefore easy to see that a veriﬁcation policy is just a collection of computation policies, one for each value of f (x n ), and the advantage of veriﬁcation is that for each value of f we can choose a policy that minimizes the expected number of queries for the given value of f (x n ).\nThe difference between veriﬁcation and computation com- plexity is perhaps easiest to demonstrate via a non-symmetric function of dependent random variables.\nExample 2: Let f : {0, 1} n → {1, ..., n} be such that f (x n ) = i iff x i = 1 and all other x j \u2019s are 0. And let X n be distributed such that for all 1 ≤ i ≤ n, X i = 1 and all other X j \u2019s are 0 with probability 1/n. For example, for n = 3, P (100) = P (010) = P (001) = 1/3, and f (100) = 1, f (010) = 2, and f (001) = 3.\nIt is easy to see that for computation we need to query the n variables till we ﬁnd one whose value is 1, hence the expected computation complexity is (n+1)/2. By contrast, for veriﬁcation, we are told the value j of f (x n ) and just need to verify that X j = 1, hence the expected veriﬁcation complexity is 1.\nNote f is not symmetric, and the X i \u2019s are dependent, we have relaxed the symmetry and independence conditions as the point of the paper is to show that with them, the computation and veriﬁcation complexities coincide.\nFor a more precise deﬁnition, the expected query complexity of policy P when f (X n ) = j is\nP (x n )N (x n ) P (f (X n ) = j)\nand the veriﬁcation complexity of f when f (X n ) = j is the smallest expected number of bits that need to be queried to verify the value of f when f (X n ) = j.\nwhere the minimum is taken over all policies that verify the value j of f . It is easy to see that the minimum can be equivalently taken over all policies computing f .\nThe minimum expected veriﬁcation query complexity or simply veriﬁcation complexity of f is therefore\nAn optimal veriﬁcation policy is one whose expected query complexity is V (f ). As with its computation counterpart, f may have several optimal veriﬁcation policies.\nSince computation is one way of veriﬁcation, or equiv- alently, since a veriﬁcation policy is a set of computation policies, one for each value of f , we see that the veriﬁcation complexity is at most the computation complexity.\nIn Section IV we show that for all symmetric functions of independent binary inputs, V (f ) = C(f ).\nRecall that symmetric functions of binary variables are determined by the input weight w(x n ) def = n i=1 x i . Divide the range [0, n] of possible weights into contiguous intervals over which the function is constant. The following observation shows that when a policy computing a function stops, the value of the function is constant in a possible interval.\nObservation 4: If for an input x n a policy stops after querying n 0 zeros and n 1 ones, then w(x n ) can take any value in the contiguous interval [n 1 , n − n 0 ]. Furthermore, if the policy computes f , then f (x n ) is constant for all x n with weight in this interval.\nProof: After querying n 0 0\u2019s and n 1 1\u2019s, \t i x i can take any value in the range [n 1 , n − n 0 ], depending on the\nvalues of the unknown inputs. Since when the policy stops, the value of the function is determined, regardless of the unknown inputs, f (x n ) must be the same for all inputs with w(x n ) ∈ [n 1 , n − n 0 ].\nThe interval indicator function of f is the function g : [0, n] → [1, n + 1], deﬁned by g(0) def = 1 and\ng(x) indicates which f -interval x belongs to. We divide intervals into two types. An interval is large if its length is at least n+1 2 and it is small otherwise.\nNext observe that f and g have the same computation complexity.\nObservation 5: For every symmetric function f of indepen- dent binary variables,\nProof: For any function f , the value of g determines the value of f , hence any policy computing g also computes f , and C(f ) ≤ C(g). Conversely, while the value of f may not determine the value of g, e.g., for the parity function, by Observation 4, when the value of f is determined, the weight x n lies in a known interval over which f is constant, and hence g is determined as well, and C(g) ≤ C(f ).\nFollowing observation compares the veriﬁcation complexi- ties of f and g.\nObservation 6: For any symmetric function f of indepen- dent binary variables,\nProof: Recall that veriﬁcation policy for f is a collection of computation policies one for each value of f (X n ). Since g determines f , the number of computation policies in g is larger, and hence a veriﬁcation policy for f is also a veriﬁcation policy for g.\nCorollary 7: For all symmetric functions f of independent binary random variables,\nOur main result, Theorem 14, shows that for all symmetric functions f of independent binary random variables, V (g) = C(g), and the corollary follows.\nIn general, veriﬁcation complexity appears to be easier to determine than computation complexity, and veriﬁcation complexity of the interval indicator functions seems easier to determine than the veriﬁcation complexity of symmetric functions. Hence in the rest of the paper we consider only the veriﬁcation complexity of interval indicator functions.\nWe now prove the equality of veriﬁcation and computation complexities of symmetric functions of independent binary inputs. Based on the size of the intervals, we ﬁnd the inputs which can be queried ﬁrst. We then show that no matter what the value of the function is, there are some inputs that can be queried ﬁrst in an optimal veriﬁcation policy.\nTo achieve this goal, in Lemma 12 we consider optimal veriﬁcation policy when the weight of the inputs belongs to large interval and we ﬁnd some inputs that one of them can be queried ﬁrst in an optimal veriﬁcation policy. In compare, when the weight of the inputs belongs to small interval, Lemma 13 ﬁnds some inputs that any of them can be queried ﬁrst in an optimal veriﬁcation policy. Combination of these two lemmas help us to ﬁnd an input that can be queried ﬁrst in an optimal veriﬁcation policy for all values of function. Lemmas 9 and 10 are the main parts of the proof of Lemmas 13 and 12 which will be stated later. We begin with an observation.\nLet I j def = {x|g(x) = j} be the j th interval of the function g. Then I j can be written as [s j , e j ] where s j and e j are the interval\u2019s start and end points. Deﬁne,\n \nThe following observation shows equality of veriﬁcation of g j (X n ) = j and veriﬁcation of g(X n ) = j.\nObservation 8: A policy veriﬁes g(X n ) = j iff it veriﬁes g j (X n ) = 2.\nEvery policy starts by querying a ﬁxed input X i and the next query is a function of the value of X i . An optimal policy is called second-input-ﬁxed if the second input queried is some ﬁxed X j independent of the value of X i . Suppose there is a function for which there exists a second-input-ﬁxed policy, that queries some two inputs X i and X j . Using the fact that the p i \u2019s are sorted and the function is symmetric, we show in the following lemma that for any index k between i and j there exists an optimal policy that queries X k ﬁrst.\nLemma 9: Let P opt be a second-input-ﬁxed optimal policy that queries X i and X j as the ﬁrst two inputs. Then for any k between i and j (inclusive), there exists an optimal policy that queries X k ﬁrst.\nProof: Figure 1 describes P opt to compute the value of g or to verify a speciﬁc value of g. Let P opt,1 , P opt,2 , and P opt,3 be policies followed after querying of X i and X j , depending on the values observed. Since the function is symmetric, in the case when X i + X j = 1, the same policy works.\nWithout loss of generality we assume that i < j. For any k ∈ [i, j], consider four policies that query X k ﬁrst. They are shown in Figure 2.\nWe brieﬂy explain the four policies above. The ﬁrst policy queries X k and then X i . It then follows P opt and queries X j when P opt requires querying X k . In the second policy X k is queried ﬁrst, and depending on its value we query X i or X j and follow P opt . When P opt requires querying X k , we query one of X i and X j that has not been queried. The remaining two policies are similarly described.\nWe now describe the expected query complexities of the various policies described above and then show that at least one of the four policies deﬁned performs as well as P opt .\nC(P opt ) =¯ p i ¯ p j (a 00 ¯ p k + b 00 p k ) + ¯ p i p j (a 01 ¯ p k + b 01 p k )+ p i ¯ p j (a 01 ¯ p k + b 01 p k ) + p i p j (a 11 ¯ p k + b 11 p k ),\nwhere a r,t and b r,t are non-negative numbers depending on the structure of P opt , for r, t ∈ {0, 1}, independent of p i , p j and p k . The complexity of the four policies deﬁned can be written as,\nC(P 1 ) =¯ p k ¯ p i (a 00 ¯ p j + b 00 p j ) + ¯ p k p i (a 01 ¯ p j + b 01 p j )+ p k ¯ p i (a 01 ¯ p j + b 01 p j ) + p k p i (a 11 ¯ p j + b 11 p j ),\nC(P 2 ) =¯ p k ¯ p i (a 00 ¯ p j + b 00 p j ) + ¯ p k p i (a 01 ¯ p j + b 01 p j )+ p k ¯ p j (a 01 ¯ p i + b 01 p i ) + p k p j (a 11 ¯ p i + b 11 p i ),\nC(P 3 ) =¯ p k ¯ p j (a 00 ¯ p i + b 00 p i ) + ¯ p k p j (a 01 ¯ p i + b 01 p i )+ p k ¯ p i (a 01 ¯ p j + b 01 p j ) + p k p i (a 11 ¯ p j + b 11 p j ),\nC(P 4 ) =¯ p k ¯ p j (a 00 ¯ p i + b 00 p i ) + ¯ p k p j (a 01 ¯ p i + b 01 p i )+ p k ¯ p j (a 01 ¯ p i + b 01 p i ) + p k p j (a 11 ¯ p i + b 11 p i ).\nNow we compare the complexity of the new four policies with the original optimal policy by subtracting C(P opt ) out of them.\nC(P 1 )−C(P opt ) = ¯ p i (p j −p k )(b 00 −a 01 )+p i (p j −p k )(b 01 −a 11 ), C(P 2 )−C(P opt ) = ¯ p i (p j −p k )(b 00 −a 01 )+p j (p i −p k )(b 01 −a 11 ), C(P 3 )−C(P opt ) = ¯ p j (p i −p k )(b 00 −a 01 )+p i (p j −p k )(b 01 −a 11 ), C(P 4 )−C(P opt ) = ¯ p j (p i −p k )(b 00 −a 01 )+p j (p i −p k )(b 01 −a 11 ).\nBy assumption, p\u2019s are sorted in decreasing order and so p i ≥ p k ≥ p j . If any of the p i , p j , and p k are equal, the lemma is trivial. So we assume that they are all different. Using these assumptions, one can see that either all of the above four quantities should be zero or at least one of them is negative. Therefore, at least one of these four policies performs as well as the optimal policy.\nNow consider an optimal policy that queries X i ﬁrst and then queries X j or X k depending on whether X i = 0 or X i = 1. Such a policy is deﬁned as second-input-varies. For given X i , X j , X k the middle index is the median of i, j, k. The corresponding X is called the middle input.\nLemma 10: For the second-input-varies policy deﬁned above, there exists an optimal policy that queries the middle input of {X i , X j , X k } ﬁrst.\nLet n min j be the minimum number of inputs that need to be queried in order to compute g, when i X i ∈ I j . The following lemma relates n min j to g.\nProof: From Observation 4, we conclude that g(x) = j for j ∈ [n 1 , n − n 0 ], where n 0 is the number of queried 0\u2019s and n 1 is the number of queried 1\u2019s. Hence, [n 1 , n − n 0 ] ⊂ I j . Therefore, n − n 0 − n 1 + 1 ≤ |I j |. Equality is achieved, when [n 1 , n − n 0 ] = I j .\nRecall that we divided intervals into two typed of small and large intervals. We prove two following lemmas regarding the ﬁrst queried input in an optimal policy when the input weight lies in a small or large interval.\nLemma 12: Suppose i X i belongs to a large interval with size L. There exists an optimal policy to verify the value of g that queries some X i ﬁrst, i ∈ [n − L + 1, L].\nProof: Let j be the index of the interval such that x ∈ I j . By Lemma 8, we can consider the function g j (x) instead of g(x). The proof is based on induction on n. Let L n,L = [X n−L+1 , X L ]. We use threshold functions as the base for induction. Depending on the position of the interval, we consider two cases. In the ﬁrst case, we use a threshold function which has a jump at L as the base for induction. The goal is to show that i X i ∈ [0, L − 1]. In [1], it has been shown that any one of [X L , X n ] can be queried ﬁrst in an optimal policy. Hence, X L ∈ L n,L . In the second case, we use a threshold function with jump at n − L + 1 as the base. The goal is to show that i X i ∈ [n − L + 1, n]. In [1] it has been shown that there exists an optimal veriﬁcation policy, which queries X n−L+1 ﬁrst.\nFor induction, suppose the lemma is true for any function, g with n = n − 1 inputs. Further, suppose that g j is not a\nthreshold function. By using Lemma 11 at least n − L + 1 inputs need to be queried. Since it is not a threshold function, L < n and at least two inputs need to be queried.\nLet P opt be an optimal policy, which queries X i ﬁrst. If X i ∈ L n,L then the induction is complete. If X i / ∈ L n,L , then either i > L or i < n − L + 1. We ﬁrst consider the case, when i > L. By induction, there is an optimal policy P opt , that chooses one of L n−1,L as the second input. Either the policy P opt is second-input-ﬁxed or second-input-varies. We consider them separately.\nIf the policy is second-input-ﬁxed, then X j ∈ L n−1,L . By Lemma 9, any one of [X j , X i ] can be queried ﬁrst in an optimal policy and [X j , X i ]∩L n,L = ∅. If the policy is second- input-varies and suppose it queries X j if X i = 0, and X k if X i = 1, such that X j , X k ∈ L n−1,L . Then, by Lemma 10, there exist an optimal policy which queries the middle input of {X i , X j , X k } ﬁrst. That input belongs to the set L n,L .\nLemma 13: Suppose i X i belongs to a small interval with size l, then querying any one of [X l , X n−l+1 ] ﬁrst, is optimal.\nProof: Proof is by induction and it is similar to the proof of Lemma 12.\nThe following theorem is the main result of the paper. It states that there exists an optimal veriﬁcation policy that is also an optimal computation policy for all symmetric functions of independent binary inputs.\nProof: Let A j denote the set of inputs that can be queried ﬁrst in some optimal veriﬁcation policy, when i X i ∈ I j . Except Π n+1\n(x) for odd n, all other symmetric functions have at most one large interval. The above theorem is proved for these exceptions in [1]. So in the rest of the proof we assume that there is at most one large interval. Let L and M be the size and index of one of the longest intervals (and observe that such an interval may not be large by our deﬁnition). Let l and i denote the size and index of an interval other than I M . We consider the following two cases, based on the size of the longest interval.\nIn addition, by Lemma 12, [X n−L+1 , X L ] ∩ A M = ∅. As a result, j A j = ∅, which implies that there is an input that can be queried ﬁrst in all optimal policies for different values of g. After the ﬁrst query, the similar argument can be used for the rest of the inputs. Hence, one can track one of the optimal veriﬁcation policies without the knowledge of the function value. As a result, C(g) = V (g).\nFrom the proof of the theorem, it is clear that, when all the intervals are at most n+1 2 , the set of inputs which can be queried ﬁrst in an optimal veriﬁcation policy is independent\nof the value of g. This result by itself can be used to ﬁnd an optimal policy for several functions, whose their longest interval is small interval.\nIn the previous section we showed that all symmetric func- tions of independent binary variables have the same computa- tion and veriﬁcation complexity. The symmetry, independence, and binary conditions are necessary in that if any of the conditions is relaxed, there are functions whose veriﬁcation complexity is strictly lower than their computation complexity. We show the result for the symmetry condition and leave the other two conditions for the full version of the paper.\nExample 15: Let X 1 , X 2 , and X 3 be independent Ber( 1 2 ), and consider the following non-symmetric function f (X 1 , X 2 , X 3 ),\nThe ﬁrst three terms correspond to function values 1, 2, and 3, each occurs with probability 1/4. In each of these cases, the function value can be veriﬁed by querying exactly two inputs. The fourth term corresponds to function value 4. In that case, querying all the three inputs is necessary to verify the value of the function. On the other hand, it can be shown that the computation complexity is 10 4 .\n[1] J. Acharya, A. Jafarpour, and A. Orlitsky, \u201cExpected Query Complexity of Symmetric Boolean Functions,\u201d Allerton Conference , 2011, pp. 26-29.\n[2] S. Arora and B. Barak, \u201cComputational Complexity: A Modern Ap- proach,\u201d 1st ed. New York, NY, USA: Cam- bridge University Press, 2009.\n[3] K. J. Arrow, L. Pesotchinsky, and M. Sobel, \u201cOn par- titioning of a sample with binary-type questions in lieu of collecting observations,\u201d Journal of the American Statistical Association , vol. 76, pp. 402-409, 1981.\n[4] Y. Ben-Asher and I. Newman, \u201cDecision trees with boolean threshold queries,\u201d Journal of Computer and System Sciences , vol. 51, pp. -, 1995.\n[5] H. Buhrman and R. de Wolf, \u201cComplexity measures and decision tree complexity: A survey,\u201d Theoretical Computer Science , vol. 288, p. 2002, 1999.\n[6] A. K. Dhulipala, C. Fragouli, and A. Orlitsky, \u201cSilence- based com- munication,\u201d IEEE Transactions on Informa- tion Theory , vol. 56, pp. 350-366, January 2010.\n[7] H. Kowshik and P. R. Kumar, \u201cOptimal ordering of trans- missions for computing boolean threshold functions,\u201d in Proceedings of IEEE Symposium on Information Theory , 2010, pp. 1863-1867.\n[8] I. Wegener, \u201cThe complexity of Boolean functions,\u201d New York, NY, USA: John Wiley & Sons, Inc., 1987."},"refs":[]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565369.pdf"},"links":[{"id":"1569564843","weight":4},{"id":"1569566527","weight":2},{"id":"1569565883","weight":3},{"id":"1569564889","weight":2},{"id":"1569566725","weight":2},{"id":"1569565377","weight":2},{"id":"1569566799","weight":2},{"id":"1569565067","weight":2},{"id":"1569559665","weight":2},{"id":"1569561021","weight":10},{"id":"1569566815","weight":2},{"id":"1569566981","weight":2},{"id":"1569566321","weight":2},{"id":"1569566605","weight":2},{"id":"1569566855","weight":2},{"id":"1569560629","weight":2},{"id":"1569566869","weight":4},{"id":"1569565097","weight":14},{"id":"1569566227","weight":6},{"id":"1569566091","weight":2},{"id":"1569559259","weight":2},{"id":"1569566697","weight":2},{"id":"1569566597","weight":2},{"id":"1569565551","weight":2},{"id":"1569566943","weight":2},{"id":"1569565091","weight":3},{"id":"1569566591","weight":2},{"id":"1569566571","weight":2},{"id":"1569552245","weight":3},{"id":"1569565607","weight":2},{"id":"1569565495","weight":7},{"id":"1569567045","weight":2},{"id":"1569564481","weight":5},{"id":"1569560833","weight":2},{"id":"1569566415","weight":2},{"id":"1569564805","weight":2},{"id":"1569567005","weight":4},{"id":"1569566081","weight":3},{"id":"1569565355","weight":3},{"id":"1569551535","weight":3},{"id":"1569565547","weight":2},{"id":"1569566871","weight":3},{"id":"1569565461","weight":2},{"id":"1569565171","weight":2},{"id":"1569566207","weight":3},{"id":"1569564227","weight":2},{"id":"1569558325","weight":2},{"id":"1569557585","weight":2},{"id":"1569566671","weight":2},{"id":"1569566303","weight":3},{"id":"1569564233","weight":2},{"id":"1569563411","weight":3},{"id":"1569564849","weight":2},{"id":"1569559541","weight":4},{"id":"1569566363","weight":2},{"id":"1569566739","weight":2},{"id":"1569555811","weight":3},{"id":"1569565291","weight":3},{"id":"1569564203","weight":3},{"id":"1569566821","weight":2},{"id":"1569565771","weight":2},{"id":"1569566999","weight":3},{"id":"1569565859","weight":2},{"id":"1569558483","weight":2},{"id":"1569566563","weight":2},{"id":"1569566089","weight":3},{"id":"1569566173","weight":3},{"id":"1569559221","weight":2},{"id":"1569556091","weight":2},{"id":"1569565347","weight":3},{"id":"1569566925","weight":2},{"id":"1569566497","weight":4},{"id":"1569566963","weight":2},{"id":"1569561679","weight":2},{"id":"1569566709","weight":2},{"id":"1569551763","weight":2},{"id":"1569565953","weight":2},{"id":"1569566889","weight":3},{"id":"1569565709","weight":2},{"id":"1569566269","weight":3},{"id":"1569564189","weight":2},{"id":"1569566985","weight":3},{"id":"1569567009","weight":3},{"id":"1569565321","weight":5},{"id":"1569558785","weight":3},{"id":"1569564647","weight":16},{"id":"1569566193","weight":4},{"id":"1569566343","weight":2},{"id":"1569565785","weight":2},{"id":"1569566679","weight":3},{"id":"1569565989","weight":12},{"id":"1569566575","weight":3},{"id":"1569563981","weight":4},{"id":"1569561085","weight":2},{"id":"1569566617","weight":2},{"id":"1569559565","weight":4},{"id":"1569566905","weight":2},{"id":"1569563307","weight":3},{"id":"1569566063","weight":2},{"id":"1569565589","weight":4},{"id":"1569559995","weight":3},{"id":"1569566657","weight":6},{"id":"1569565213","weight":6},{"id":"1569566643","weight":9},{"id":"1569566511","weight":2},{"id":"1569566991","weight":2},{"id":"1569566975","weight":19},{"id":"1569566369","weight":2},{"id":"1569566531","weight":2},{"id":"1569567665","weight":2},{"id":"1569561143","weight":2},{"id":"1569566581","weight":2},{"id":"1569566489","weight":3},{"id":"1569562867","weight":2},{"id":"1569566395","weight":3},{"id":"1569561795","weight":2},{"id":"1569567015","weight":7},{"id":"1569559805","weight":3},{"id":"1569566437","weight":2},{"id":"1569565735","weight":3},{"id":"1569553537","weight":2},{"id":"1569565427","weight":4},{"id":"1569565839","weight":2},{"id":"1569565915","weight":2},{"id":"1569552251","weight":2},{"id":"1569553519","weight":3},{"id":"1569566425","weight":3},{"id":"1569554971","weight":3},{"id":"1569565501","weight":3},{"id":"1569566899","weight":26},{"id":"1569566445","weight":2},{"id":"1569566209","weight":3},{"id":"1569566649","weight":6},{"id":"1569565559","weight":2},{"id":"1569566371","weight":2},{"id":"1569565655","weight":3},{"id":"1569566127","weight":2},{"id":"1569563763","weight":2},{"id":"1569566473","weight":2},{"id":"1569564857","weight":2},{"id":"1569566913","weight":3},{"id":"1569566629","weight":2},{"id":"1569565033","weight":2},{"id":"1569566447","weight":2},{"id":"1569565847","weight":2},{"id":"1569566141","weight":3},{"id":"1569565055","weight":2},{"id":"1569565633","weight":2},{"id":"1569565279","weight":38},{"id":"1569555879","weight":2},{"id":"1569566115","weight":2},{"id":"1569564851","weight":2},{"id":"1569565595","weight":3},{"id":"1569566773","weight":2},{"id":"1569564985","weight":2},{"id":"1569566223","weight":3},{"id":"1569566553","weight":2},{"id":"1569565029","weight":2},{"id":"1569566505","weight":2},{"id":"1569565933","weight":3},{"id":"1569562207","weight":4},{"id":"1569567033","weight":3},{"id":"1569565527","weight":3},{"id":"1569565363","weight":15},{"id":"1569566159","weight":2},{"id":"1569566051","weight":2},{"id":"1569561379","weight":5},{"id":"1569561123","weight":2},{"id":"1569565467","weight":2},{"id":"1569565441","weight":10},{"id":"1569565739","weight":12},{"id":"1569566233","weight":2},{"id":"1569566893","weight":2},{"id":"1569560997","weight":3},{"id":"1569566501","weight":2},{"id":"1569565741","weight":4},{"id":"1569566481","weight":2},{"id":"1569566857","weight":2},{"id":"1569566245","weight":2},{"id":"1569566229","weight":3},{"id":"1569562551","weight":2},{"id":"1569551347","weight":2},{"id":"1569565415","weight":2},{"id":"1569561623","weight":2},{"id":"1569564485","weight":3},{"id":"1569566631","weight":2},{"id":"1569565571","weight":2},{"id":"1569565885","weight":2},{"id":"1569566177","weight":2},{"id":"1569565493","weight":2},{"id":"1569557633","weight":3},{"id":"1569566805","weight":2},{"id":"1569566293","weight":2},{"id":"1569565665","weight":2},{"id":"1569566831","weight":2},{"id":"1569565549","weight":9},{"id":"1569565523","weight":5},{"id":"1569565611","weight":2},{"id":"1569557715","weight":2},{"id":"1569564175","weight":2},{"id":"1569566097","weight":3},{"id":"1569566431","weight":3},{"id":"1569565397","weight":2},{"id":"1569566873","weight":2},{"id":"1569565765","weight":4},{"id":"1569565435","weight":2},{"id":"1569565575","weight":18},{"id":"1569565919","weight":4},{"id":"1569565181","weight":15},{"id":"1569566711","weight":3},{"id":"1569565273","weight":3},{"id":"1569566267","weight":2},{"id":"1569564919","weight":3},{"id":"1569566737","weight":3},{"id":"1569561221","weight":2},{"id":"1569566917","weight":5},{"id":"1569565353","weight":3},{"id":"1569564683","weight":3},{"id":"1569564305","weight":3},{"id":"1569565421","weight":3},{"id":"1569566715","weight":2},{"id":"1569565237","weight":2},{"id":"1569566639","weight":2},{"id":"1569565041","weight":2},{"id":"1569564703","weight":2},{"id":"1569565293","weight":2},{"id":"1569562277","weight":2},{"id":"1569566977","weight":3},{"id":"1569564437","weight":4},{"id":"1569564861","weight":2},{"id":"1569565457","weight":2},{"id":"1569564787","weight":2},{"id":"1569566487","weight":2},{"id":"1569565529","weight":2},{"id":"1569566619","weight":2},{"id":"1569561185","weight":3},{"id":"1569566397","weight":2},{"id":"1569558779","weight":2},{"id":"1569566817","weight":2},{"id":"1569565729","weight":2},{"id":"1569566299","weight":3},{"id":"1569564281","weight":2},{"id":"1569565805","weight":3},{"id":"1569561713","weight":2},{"id":"1569563919","weight":2},{"id":"1569566577","weight":2},{"id":"1569565389","weight":2},{"id":"1569559919","weight":2},{"id":"1569565537","weight":3},{"id":"1569562367","weight":2},{"id":"1569560213","weight":2},{"id":"1569565997","weight":3},{"id":"1569565035","weight":5},{"id":"1569559251","weight":2},{"id":"1569561861","weight":2},{"id":"1569565737","weight":2},{"id":"1569566807","weight":14},{"id":"1569564463","weight":3},{"id":"1569564123","weight":3},{"id":"1569565889","weight":2},{"id":"1569563725","weight":2},{"id":"1569551539","weight":2},{"id":"1569564505","weight":3},{"id":"1569565565","weight":3},{"id":"1569565635","weight":2},{"id":"1569566797","weight":2},{"id":"1569566413","weight":2},{"id":"1569565707","weight":2},{"id":"1569566375","weight":2},{"id":"1569565143","weight":2},{"id":"1569564257","weight":2},{"id":"1569566555","weight":3},{"id":"1569566973","weight":2},{"id":"1569561579","weight":2},{"id":"1569566987","weight":2},{"id":"1569551541","weight":2},{"id":"1569566839","weight":5},{"id":"1569566663","weight":2},{"id":"1569565579","weight":2},{"id":"1569566067","weight":2},{"id":"1569566825","weight":3},{"id":"1569563007","weight":4},{"id":"1569566113","weight":2},{"id":"1569566443","weight":4},{"id":"1569566727","weight":4},{"id":"1569560581","weight":13}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S15.T6.2","endtime":"10:30","authors":"Hirakendu Das, Ashkan Jafarpour, Alon  Orlitsky, Shengjun Pan, Ananda Theertha Suresh","date":"1341569400000","papertitle":"On the Query Computation and Verification of Functions","starttime":"10:10","session":"S15.T6: Fundamental Limits on Complexity","room":"Kresge Rehearsal A (033)","paperid":"1569565369"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"3","spectral14":"7","spectral20":"18","spectral9":"3","spectral3":"1","spectral17":"13","louvain":"6","spectral10":"0","spectral15":"0","spectral5":"4","spectral8":"1","spectral11":"6","spectral4":"2","spectral12":"6","spectral19":"1","spectral7":"5","spectral13":"8","spectral18":"17","spectral2":"0","spectral16":"9"}}
