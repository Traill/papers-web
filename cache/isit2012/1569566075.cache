{"id":"1569566075","paper":{"title":{"text":"Making WOM Codes Decodable Using Short Synchronous WOM Codes"},"authors":[{"name":"Nicolas Bitouz´e \u2020"},{"name":"Alexandre Graell i Amat \u2021"},{"name":"Eirik Rosnes §"}],"abstr":{"text":"Abstract\u2014While some write once memory (WOM) codes are inherently decodable, others require the added knowledge of the current generation in order to successfully decode the state of the memory. If there is no limit on the code length, n, a binary non-decodable t-write WOM code can be made decodable at an insigniﬁcant cost in terms of code rate by adding t − 1 cells to store the current generation after replicating the code enough times for the t − 1 cells to be of negligible weight. This justiﬁes the research on non-decodable WOM codes. However, if n is bounded, the t − 1 additional cells may introduce a signiﬁcant loss in terms of code rate. In this paper, we propose a new method to make non-decodable WOM codes decodable at a lower price when n is bounded. The main idea is to add cells that do not only store the current generation, but also additional data, by using a synchronous (t − 1)-write WOM code of length t − 1 or slightly above which does not contain the all-zero codeword. A bound on the rate of a simple family of synchronous WOM codes with n = t is given, as well as very short codes from this family. Better codes are then obtained by local manipulations of these codes. Finally, a construction of synchronous WOM codes with good properties is proposed to reach higher values of t."},"body":{"text":"A write once memory (WOM) [1] is a storage device consisting of memory cells that take on q ≥ 2 possible states in {0, . . . , q −1}, and such that the state of a given cell cannot be decreased. The main problem in the WOM model is to know how much information can be stored into n q-ary memory cells using t writes (also called generations), starting from the all-zero state. Formally, we are looking for t-write WOM codes, which are codes designed to store and update data in the WOMs using t writes. WOM codes are deﬁned by their t encoding and decoding maps. The following deﬁnition is taken from [2]:\nDeﬁnition 1: An [n, t : M 1 , . . . , M t ] t-write q-ary WOM code C is a coding scheme for n q-ary WOM cells, which consists of t pairs of encoding and decoding maps E i and D i (1 ≤ i ≤ t) such that:\n\u2022 E i : {1, . . . , M i } × Im(E i−1 ) → {0, . . . , q − 1} n , \u2022 ∀(m, c) ∈ {1, . . . , M i } × Im(E i−1 ),\n3) For 1 ≤ i ≤ t, D i : {0, . . . , q − 1} n → {1, . . . , M i }, and\n\u2022 for 2 ≤ i ≤ t, ∀(m, c) ∈ {1, . . . , M i } × Im(E i−1 ), D i (E i (m, c)) = m.\nFor simplicity, in the remainder of the paper, we will refer to WOM codes simply as codes. The rate of the above code, referred to as the WOM-rate, is deﬁned as follows [2]:\nDeﬁnition 2: The rate of generation i ∈ {1, . . . , t} of an [n, t : M 1 , . . . , M t ] q-ary code C is\nlog q M i n\nGiven t, q and sometimes n, one would like to maximize the WOM-rate. In this paper, we only consider binary codes, i.e., q = 2.\nDepending on the structure of the code, the state of the cells may or may not sufﬁce to determine the current generation (i.e., how many times the block has been written, and which map D i should be used to decode). In other words, the code is not always decodable. We call decodable codes the codes such that for any state of the cells c and any i 1 and i 2 with c ∈ Im(E i 1 ) ∩ Im(E i 2 ), D i 1 (c) = D i 2 (c). A code is called synchronous [1] if a given state of the cells can only be reached at a given generation, i.e., the sets Im(E i ) are disjoint for 1 ≤ i ≤ t. A simple way to guarantee that a code is syn- chronous is to force the Hamming weight w of the cells to be an injective function of the generation, i.e., for c 1 ∈ Im(E i 1 ) and c 2 ∈ Im(E i 2 ), w(c 1 ) = w(c 2 ) ⇒ i 1 = i 2 . These codes are called laminar in [1]. By construction, synchronous codes are decodable. A construction of synchronous (and laminar) codes was given in [1] for n = t being a power of two, and WOM-rate log 2 (t)/2. However, synchronous codes have not been extensively studied. Non-synchronous codes can still be directly decoded if, when the decoder cannot determine the current generation, the choice of D i has no impact on the decoded symbol. Notice that synchronous codes are decodable, but the reverse does not always hold. For later use, if an [n, t :\nM 1 , . . . , M t ] code is synchronous (respectively decodable), we will use the superscript \u201csync\u201d, [n, t : M 1 , . . . , M t ] sync (respectively \u201cdec\u201d, [n, t : M 1 , . . . , M t ] dec ). Also, the binary cells that can be written from 0 to 1 but not from 1 to 0 are called wits [1].\nA non-decodable code C with parameters [n, t : M 1 , . . . , M t ] can be turned into a decodable (and even syn- chronous) code by simply concatenating k instances of C with a block of t − 1 cells that stores the current generation (by being ﬁlled one by one at each write, starting at the second generation). The resulting code is a synchronous code with parameters [kn + t − 1, t : M k 1 , . . . , M k t ]. Note that if k goes to inﬁnity, the WOM-rate of this code goes to the WOM-rate of the original code C, R(C). A common approach in the literature is to design codes that approach the boundaries of the capacity region (see, e.g., [2], [3]), and then make them decodable using this method. Therefore, most of the state-of- the-art high-rate codes are not directly decodable. However, if the target application speciﬁes t and n, making a non- decodable code decodable using the above-mentioned method can signiﬁcantly degrade its WOM-rate. For instance, consider n = 6 and t = 4, and assume that we do not know a decodable code of length 6. In this case, we could select a non-decodable 4-write code of length 3, and append 3 cells to store the current generation. The resulting WOM-rate is half the original one, as the additional cells only carry information about the current generation.\nNotice that if the system must be able to know, when the state of the memory is the all-zero vector, whether this is because the block is empty or because it contains the all- zero codeword, then adding t − 1 cells is not enough to make the code decodable, but t cells are required in this case, instead. Here we consider the case where t − 1 additional cells are enough. The analysis for the other scenario is extremely similar.\nIn this paper, we propose a different approach to make a non-decodable t-write code C decodable. The key idea is to append t − 1 additional cells which store not only the current generation but also new data, by using a t-write synchronous code with length t − 1, and writing generations of C and of the synchronous code simultaneously. In the scenario where the system must know the difference between the all-zero codeword and an empty block of memory, a t- write synchronous code of length t which does not contain the all-zero codeword would be required. To unify the search for codes for both scenarios, we search for codes with n = t which do not contain the all-zero codeword, and we turn them into a code suited for the scenario where the distinction between the all-zero codeword and an empty block is not required, by adding a generation that only contains the all- zero codeword. Then, synchronousness guarantees that by observing the t−1 new cells, the decoder can always determine the current generation, and use this knowledge to decode the obtained code. We also consider using t-write synchronous codes with length slightly above t−1 (the length should remain small, because we do not expect to ﬁnd synchronous codes of\nWOM-rate higher than non-decodable ones, thus the highest number of cells should be reserved to the non-decodable code). In particular, our focus is on binary laminar codes, but the proposed approach can be extended to non-laminar codes and non-binary codes.\nIn this section, we focus on building laminar codes with n = t, that write exactly 1 wit at each generation. Also, in order to simplify the problem, we try to maximize the values of M i generation by generation, rather than globally maximizing the WOM-rate. Consider a code C with n = t that writes exactly 1 wit per generation, and a generation i > 1. Assuming that the previous generations are already ﬁxed, the condition we have on M i is that for every x ∈ Im(E i−1 ), and for every m ∈ {1, . . . , M i }, there exists y ∈ Im(E i ) such that x ≤ y and D i (y) = m (where x ≤ y if x k ≤ y k for all k, 1 ≤ k ≤ n). Denote by E n i the set of binary vectors of length n and Hamming weight i. It follows that at each generation i, Im(E i ) ⊆ E n i . We use this set inclusion to make our maximization at each generation completely independent from the other generations, at the cost of optimality.\nLet us deﬁne the equivalence relation ≡ n i on Im(E i ) by y ≡ n i y if and only if D i (y) = D i (y ). Let us refer to the equivalence classes of this relation as the codeword classes of C at generation i. Codeword classes are subsets Y ⊆ E n i for which, if we do not take the previous generations into account, the following must hold:\nWe are also interested in the partitions of E n i as a set of valid codeword classes. If Y denotes such a partition, we want that\nEach valid partition Y corresponds to a valid decoding map (modulo reordering), and thus each cardinality |Y| to a valid M i . We are therefore interested in ﬁnding the maximum cardinality, denoted by A i (n), of such a partition. We give an upper bound on A i (n):\n   \n   \nThen, the maximum cardinality A i (n) of a partition Y that satisﬁes (4) is upper bounded by A i (n) ≤ B i (n).\nThis bound can be computed using a computer search for the smallest Y that satisﬁes (3). The search is relatively slow, but notice that by lower-bounding |Y | by |E n i−1 | i (each element\ny ∈ E n i covers exactly i elements x ∈ E n i−1 ), we obtain a closed-form bound:\n   \n   \n     \n     \nWhile the closed-form bound can be computed efﬁciently and is reached for some values of (n, i) (for instance, for n ≤ 3, or for i ≤ 2, or i = n), even for relatively low values of n and i, it can be strictly higher than A i (n). For instance, A 3 (4) = 1, while the closed-form bound is 2. Indeed, E 4 3 = {1110, 1101, 1011, 0111} and E 4 2 = {1100, 1010, 1001, 0110, 0101, 0011}, and while each element of E 4 3 covers 3 elements of E 4 2 , it is not possible to pick two elements of E 4 3 that cover distinct elements of E 4 2 . Therefore, the codeword classes in E 4 3 have cardinality at least 3, and not\nFor very small values of n, the exact value of A i (n) can be computed by conducting a simple exhaustive search on the set of codeword classes. Values of B i (n) are also obtained with an exhaustive search, but on the minimum size of codeword classes, which is signiﬁcantly faster. The results of the two searches are reported for n ≤ 16 in Table I. The values in bold font are A i (n), the others are B i (n). The few values of A i (n) that were computed exactly match B i (n), so it is unknown whether there are pairs (n, i) such that A i (n) < B i (n). Note that these values are constructive. For instance, a [4, 4 : 4, 3, 1, 1] sync and a [5, 5 : 5, 3, 2, 1, 1] sync code can be obtained from the search.\nThe constraints that we applied on the codes of Section II, especially the constraint that n = t, keep the code WOM- rates relatively low. Lifting the constraint on n = t allows for higher WOM-rates, and laminar codes with n slightly larger than t can easily be derived from codes obtained as\nin Section II by merging several generations together: taking, as the new set of codeword classes, the union of the sets of codeword classes of two or more consecutive generations. For instance, the [4, 4 : 4, 3, 1, 1] sync code can be turned into a [4, 3 : 4, 3, 2] sync code by merging its third and fourth generations together. Instead of having one codeword class at generation 3 ({1110, 1101, 1011, 0111}) and one at generation 4 ({1111}), now the third generation has two codeword classes: {1110, 1101, 1011, 0111} and {1111}, and there is no fourth generation anymore. Likewise, a [5, 3 : 5, 3, 4] sync code (of WOM-rate 1.181) can be derived from the [5, 5 : 5, 3, 2, 1, 1] sync code by merging the last three generations together. However, consider the codeword classes of vectors of weight 4. These were constructed in order to cover every word of weight 3, while they now only have to cover every word of weight 2. The optimization also did not allow codeword classes of mixed weights. We can reorganize the set of vectors of weight 3 or more into a better balanced set of codeword classes. In (8), we give the codeword classes of the third generation of a [5, 3 : 5, 3, 6] sync code (of WOM- rate 1.298) obtained by reorganizing the third generation of the [5, 3 : 5, 3, 4] sync code:\n{01111, 11001, 10110}, {10111, 11100, 01011}, {11011, 01110, 10101}, {11101, 00111, 11010},\nFor comparison, the 4 codeword classes of the third gener- ation of the [5, 3 : 5, 3, 4] sync code are:\n{11100, 11010, 10101, 01011, 00111} (weight 3 only), {11001, 10110, 10011, 01110, 01101} (weight 3 only), {11110, 11101, 11011, 10111, 01111} (weight 4 only),\nOther choices can be made regarding which generations to merge to obtain a 3-write code from the [5, 5 : 5, 3, 2, 1, 1] sync code, but lower WOM-rates are obtained.\nWe propose a construction to obtain synchronous codes for higher values of t by concatenating n instances of a synchronous code of length n, and using a second synchronous code of length n to decide, at each generation, which of the n instances of the ﬁrst code are going to be modiﬁed.\nTheorem 1: Let C be an [n, t : M 1 , . . . , M t ] synchronous code of WOM-rate R, and C an [n , t : M 1 , . . . , M t ] synchronous code of WOM-rate R . Then there exists an [nn , tt : M 1 M 1 , . . . , M 1 M t , . . . , M t M 1 , . . . , M t M t ] syn- chronous code C 1 of WOM-rate R 1 = t n R + t n R .\nA formal proof is omitted here, and we only give the idea of how the construction works. We ﬁrst consider only the case where n = t (in which C writes exactly one wit at each generation). The key idea is that the nn wits of C 1 are divided into n blocks of n wits, and the tt generations are divided into t stages of t generations. In the ﬁrst stage, during each of the ﬁrst t generations we use the encoding function of the ﬁrst generation of C to write in exactly one empty block of n cells. C tells us which of the n blocks is going to be written: it writes exactly one wit among n per generation, which we map to one block among the n blocks at each generation. After this ﬁrst stage, each block contains a codeword of the ﬁrst generation of C. During the second stage, we use the encoding function of the second generation of C, and C once again points to the block that will be written. This process is repeated for all t stages. Thus, during the l-th generation of the p-th stage (1 ≤ p ≤ t, 1 ≤ l ≤ t ), we pick messages in {1, . . . , M p × M l }, and each message m 1 can be mapped to a pair of messages (m, m ) ∈ {1, . . . , M p } × {1, . . . , M l }.\nFrom the decoder perspective, at all times, either every block has codewords of the same generation p of C, or there are blocks at generation p and blocks at generation p − 1. Because C is synchronous, the decoder has knowledge of the value of p (the current stage). Let c = (c 1 , . . . , c n ) where c k = 0 if the k-th block is at generation p − 1 and c k = 1 if the k-th block is at generation p. The decoder knows c and therefore m . However, it does not have knowledge of which block of wits was written last. Therefore, we do not directly encode m in the block that is written: instead, we encode a message m 0 such that by decoding every block of wits at generation p using C, and then taking the modulo M p sum of the decoded messages in {1, . . . , M p }, we recover m. m 0 is (modulo M p ) m minus the sum of the decoded messages of all the blocks at generation p (the encoder must therefore be able to decode C).\nNow, if n = t , C may write several wits during some generations. When this happens, the encoder of C 1 writes in every block pointed at by C , once again so that the modulo M p sum of the decoded messages is m. Here, there are more degrees of freedom than in the case n = t (in which m 0 was fully determined). A simple way to deterministically choose the values that we encode in each of the blocks that will be written is to encode M p in each block but the last, and then\nencode the same m 0 as in the case n = t (since adding M p has no effect modulo M p ).\nlog(M p M l ) nn\nD −1 1 \t {0001} \t {0010} \t {0100} \t {1000} D −1 2 \t {1100, 0011} {1010, 0101} {1001, 0110} \t − D −1 3 \t {0111, 1011, 1101, 1110} \t {1111} \t − \t −\nLet C be the [2, 2 : 2, 1] sync code deﬁned by: 1 \t 2\n(D 1 ) −1 {01} {10} (D 2 ) −1 {11} −\nThe code C 1 obtained with the construction is a [8, 6 : 8, 4, 6, 3, 4, 2] sync code. Consider that the eight cells are in state (c 1 , c 2 ) = (1100, 0010). Let us ﬁrst consider the decod- ing of the message. The generation in C of the ﬁrst block c 1 is 2, and that of the second block c 2 is 1, thus p = 2 (the highest of the two) and c = (10). The fact that C is synchronous guarantees that only one encoding function of C has c in its range: here, it is the encoding function for l = 1. Thus, we are at the ﬁrst generation (l = 1) of the second stage (p = 2), so the overall generation is i = (p−1)t +l = (2−1)×2+1 = 3.\nWe have m = D 1 (10) = 2. m is the modulo M p sum of D p (c k ) for all indices k of a block at generation p of C. Here, there is only one block at generation p = 2 for C: block c 1 = (1100), therefore m = D 2 (c 1 ) (mod 3) = 1. The original message pair was therefore (1, 2). This can be mapped to m 1 ∈ {1, . . . , M p × M l } by m 1 = (m − 1)M l + m , for instance, which gives m 1 = 0 × 2 + 2 = 2.\nLet us now encode a new message m 1 = 2 ∈ {1, 2, 3} for generation 4. Our new m and m are 2 and 1, respectively, so that (m − 1)M l + m = (2 − 1) × 1 + 1 = 2. c = (10) will become c = (11) because E 2 (1, 10) = (11). Therefore, the second block is going to be written (because the second wit of c changes). We ﬁrst decode all the blocks already at generation p = 2: here, we only have one block at generation p = 2, and D 2 (c 1 ) = D 2 (1100) = 1. We therefore encode in the second block c 2 a message m 0 such that 1 + m 0 = m (mod M p ), where M p = M 2 = 3 and m = 2. Thus, m 0 = 1. c 2 is then replaced by E p (1, 0010) = (0011). The state of the cells is (1100, 0011) after this encoding phase.\nLet us denote by F (C, C ) the code obtained by applying the construction of Theorem 1 to C and C . We can iterate the above construction by choosing C and C , and then deﬁning C 0 = C and for all m > 0, C m = F (C m−1 , C ). This generates codes with even higher values of t, which have to be compared with a construction of synchronous codes from [1] (where n = t is any power of two and the WOM-rate is log 2 (t)/2). Notice that the two constructions happen to match when we take as C = C the trivial [2, 2 : 2, 1] sync code.\nFirst, we restrict ourselves to codes with n = t (which are easier to compare) and we ﬁx C = C. The WOM-rate of the t m -write code C m after m iterations of the construction is\n(11) Therefore, for codes with n = t, the higher R(C) log\nis, the better this iterated construction works. The code that maximizes this ratio among those found by our computer search is the one with n = t = 2 (with R(C) log\n= 1 2 ), making the codes from [1] the best in terms of asymptotic WOM-rate until codes for higher values of n = t are found. For instance, Table I suggests that a [8, 8 : 8, 7, 5, 5, 2, 2, 1, 1] sync code could exist, with a ratio of 0.519 (and even better synchronous codes could exist even for n = t = 8, if we remove the added constraints from Section II). However, when the code length is not a power of two, our construction yields codes with lengths of the form 2 a 3 b 5 c by mixing different elementary codes of lengths 2, 3, and 5 as the C codes, instead of always using the length-2 code. This is a much denser coverage of the potential values of t. Furthermore, if we consider codes with n slightly greater than t, we can reach higher WOM-rates at equal values of t. Consider, for instance, the code F (C, C ) with C the [4, 3 : 4, 3, 2] sync code and C the [2, 2 : 2, 1] sync code. The construction then yields a [8, 6 : 8, 4, 6, 3, 4, 2] sync code of WOM-rate 1.512 (larger than log 2 (t)/2 both for t = 6 and t = 8). This is the example code of Section IV-A.\nWe compare our method of making WOM codes decodable with the method that adds t − 1 data-less cells. For this comparison, we consider two different target code lengths: n = 64 and n = 256. We then assume, for each value of n and for t between 4 and 7, that there is a code with WOM- rate equal to the best currently known WOM-rate for t-write codes (from [4]), and with length n minus the length of the synchronous code that we concatenate to it. We do not use the actual code lengths at which these state-of-the-art WOM-rates are reached because they are very large [5].\nThe results are reported in Tables II and III. The second column of each table reports the state-of-the-art WOM-rate of non-decodable codes, for each value of t. The third column shows the WOM-rate that would be obtained by appending t − 1 data-less cells to a code of length n − t + 1 and WOM- rate equal to the one reported in the second column. The last two columns show, for various synchronous codes, the WOM-rate that we obtain for the same target length. The [3, 3 : 3, 1, 1] sync , [4, 4 : 4, 3, 1, 1] sync , [5, 5 : 5, 3, 2, 1, 1] sync , and [6, 6 : 6, 5, 3, 1, 1, 1] sync codes are from Section II, the [5, 3 : 5, 3, 6] sync code is from Section III, and the [8, 6 : 8, 4, 6, 3, 4, 2] sync code is from the construction of Section IV. Note that our technique yields higher WOM-rates compared to just appending a block of t − 1 cells with no information, for both target lengths. These WOM-rates are (to the best of our knowledge) also higher than the best WOM-rates for binary multiple-write codes (and hence better than the rates of any directly decodable code) known prior to [4], which justiﬁes our approach.\nIn this paper, we proposed short synchronous WOM codes as a basic tool to make non-decodable WOM codes decodable while preserving the WOM-rate as much as possible. We derived bounds for a simple family of short synchronous WOM codes, and constructed some synchronous WOM codes for small values of t. Furthermore, we proposed a construction method to build synchronous WOM codes for higher values of t obtained by concatenating shorter synchronous WOM codes.\nThe authors wish to thank S. Kayser for the valuable discussion."},"refs":[{"authors":[{"name":"R. L. Rivest"},{"name":"A. Shamir"}],"title":{"text":"How to reuse a \u201cwrite-once\u201d memory"}},{"authors":[{"name":"R. Gabrys"},{"name":"E. Yaakobi"},{"name":"L. Dolecek"},{"name":"P. H. Siegel"},{"name":"A. Vardy"},{"name":"J. K. Wolf"}],"title":{"text":"Non-binary WOM-codes for multilevel ﬂash memories"}},{"authors":[{"name":"E. Yaakobi"},{"name":"S. Kayser"},{"name":"P. H. Siegel"},{"name":"A. Vardy"},{"name":"J. K. Wolf"}],"title":{"text":"Efﬁcient two-write WOM-codes"}},{"authors":[{"name":"S. Kayser"},{"name":"E. Yaakobi"},{"name":"P. H. Siegel"},{"name":"A. Vardy"},{"name":"J. K. Wolf"}],"title":{"text":"Multiple- write WOM-codes"}},{"authors":[{"name":"S. Kayse"}],"title":{"text":""}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566075.pdf"},"links":[{"id":"1569566567","weight":2},{"id":"1569564843","weight":4},{"id":"1569566527","weight":3},{"id":"1569566485","weight":3},{"id":"1569565883","weight":6},{"id":"1569564889","weight":2},{"id":"1569566725","weight":5},{"id":"1569565663","weight":3},{"id":"1569565377","weight":2},{"id":"1569566385","weight":2},{"id":"1569564635","weight":3},{"id":"1569565867","weight":2},{"id":"1569566799","weight":2},{"id":"1569565067","weight":2},{"id":"1569559665","weight":3},{"id":"1569561021","weight":2},{"id":"1569566875","weight":3},{"id":"1569564605","weight":2},{"id":"1569559617","weight":3},{"id":"1569566981","weight":2},{"id":"1569566321","weight":3},{"id":"1569566605","weight":2},{"id":"1569565489","weight":2},{"id":"1569566683","weight":6},{"id":"1569560629","weight":2},{"id":"1569566869","weight":4},{"id":"1569566091","weight":2},{"id":"1569559259","weight":2},{"id":"1569566697","weight":3},{"id":"1569566597","weight":4},{"id":"1569565551","weight":2},{"id":"1569565711","weight":3},{"id":"1569566943","weight":4},{"id":"1569565091","weight":6},{"id":"1569566591","weight":2},{"id":"1569566571","weight":7},{"id":"1569552245","weight":3},{"id":"1569565495","weight":3},{"id":"1569559967","weight":5},{"id":"1569567045","weight":3},{"id":"1569564481","weight":4},{"id":"1569560833","weight":3},{"id":"1569566415","weight":4},{"id":"1569564805","weight":6},{"id":"1569567005","weight":2},{"id":"1569566469","weight":2},{"id":"1569566081","weight":4},{"id":"1569565355","weight":3},{"id":"1569564469","weight":2},{"id":"1569565931","weight":4},{"id":"1569566373","weight":2},{"id":"1569566647","weight":2},{"id":"1569551535","weight":4},{"id":"1569564897","weight":2},{"id":"1569565775","weight":6},{"id":"1569566871","weight":8},{"id":"1569565461","weight":6},{"id":"1569564731","weight":2},{"id":"1569566207","weight":7},{"id":"1569564227","weight":3},{"id":"1569558325","weight":2},{"id":"1569566671","weight":3},{"id":"1569564233","weight":5},{"id":"1569567535","weight":2},{"id":"1569563411","weight":4},{"id":"1569560427","weight":2},{"id":"1569564849","weight":5},{"id":"1569565317","weight":16},{"id":"1569566363","weight":2},{"id":"1569566941","weight":2},{"id":"1569566739","weight":2},{"id":"1569555811","weight":2},{"id":"1569558459","weight":2},{"id":"1569565609","weight":3},{"id":"1569565291","weight":10},{"id":"1569564203","weight":4},{"id":"1569566821","weight":2},{"id":"1569556713","weight":4},{"id":"1569562685","weight":2},{"id":"1569566467","weight":2},{"id":"1569566157","weight":2},{"id":"1569566903","weight":3},{"id":"1569565859","weight":6},{"id":"1569564249","weight":75},{"id":"1569565809","weight":4},{"id":"1569566579","weight":2},{"id":"1569566563","weight":4},{"id":"1569566089","weight":2},{"id":"1569559221","weight":2},{"id":"1569556091","weight":2},{"id":"1569565347","weight":2},{"id":"1569566925","weight":3},{"id":"1569564387","weight":2},{"id":"1569565455","weight":3},{"id":"1569566497","weight":2},{"id":"1569566795","weight":2},{"id":"1569566963","weight":4},{"id":"1569561679","weight":2},{"id":"1569566709","weight":3},{"id":"1569564989","weight":3},{"id":"1569566787","weight":5},{"id":"1569566717","weight":4},{"id":"1569566015","weight":2},{"id":"1569565897","weight":5},{"id":"1569551763","weight":4},{"id":"1569565953","weight":2},{"id":"1569566895","weight":3},{"id":"1569565709","weight":2},{"id":"1569566749","weight":2},{"id":"1569566269","weight":5},{"id":"1569564189","weight":3},{"id":"1569564195","weight":3},{"id":"1569561513","weight":2},{"id":"1569566985","weight":2},{"id":"1569564613","weight":3},{"id":"1569567009","weight":3},{"id":"1569566865","weight":4},{"id":"1569558785","weight":3},{"id":"1569566193","weight":3},{"id":"1569565907","weight":3},{"id":"1569566343","weight":3},{"id":"1569564311","weight":3},{"id":"1569565803","weight":2},{"id":"1569565785","weight":6},{"id":"1569566239","weight":2},{"id":"1569566679","weight":4},{"id":"1569565989","weight":2},{"id":"1569566575","weight":4},{"id":"1569563981","weight":3},{"id":"1569561085","weight":2},{"id":"1569566617","weight":2},{"id":"1569559565","weight":5},{"id":"1569566905","weight":5},{"id":"1569566733","weight":4},{"id":"1569563307","weight":3},{"id":"1569566063","weight":2},{"id":"1569566759","weight":3},{"id":"1569559195","weight":2},{"id":"1569566149","weight":4},{"id":"1569559995","weight":2},{"id":"1569566217","weight":2},{"id":"1569566657","weight":3},{"id":"1569558859","weight":15},{"id":"1569565199","weight":3},{"id":"1569565213","weight":2},{"id":"1569565365","weight":2},{"id":"1569566643","weight":3},{"id":"1569566511","weight":5},{"id":"1569566719","weight":2},{"id":"1569566369","weight":3},{"id":"1569566531","weight":3},{"id":"1569567665","weight":6},{"id":"1569561143","weight":4},{"id":"1569566581","weight":2},{"id":"1569565833","weight":5},{"id":"1569564611","weight":3},{"id":"1569565535","weight":2},{"id":"1569562867","weight":3},{"id":"1569565667","weight":4},{"id":"1569566845","weight":3},{"id":"1569566325","weight":2},{"id":"1569566423","weight":73},{"id":"1569565257","weight":2},{"id":"1569567015","weight":3},{"id":"1569559805","weight":3},{"id":"1569566437","weight":3},{"id":"1569566851","weight":2},{"id":"1569558901","weight":8},{"id":"1569565735","weight":2},{"id":"1569553909","weight":2},{"id":"1569559111","weight":3},{"id":"1569566687","weight":2},{"id":"1569553537","weight":4},{"id":"1569565427","weight":2},{"id":"1569566403","weight":17},{"id":"1569565839","weight":2},{"id":"1569565915","weight":2},{"id":"1569552251","weight":3},{"id":"1569566139","weight":2},{"id":"1569553519","weight":2},{"id":"1569567051","weight":2},{"id":"1569566885","weight":3},{"id":"1569566231","weight":2},{"id":"1569564209","weight":2},{"id":"1569566513","weight":8},{"id":"1569566425","weight":24},{"id":"1569554881","weight":3},{"id":"1569554971","weight":4},{"id":"1569565501","weight":3},{"id":"1569566209","weight":4},{"id":"1569566649","weight":2},{"id":"1569566791","weight":2},{"id":"1569565559","weight":2},{"id":"1569566371","weight":2},{"id":"1569565655","weight":5},{"id":"1569566909","weight":3},{"id":"1569566127","weight":3},{"id":"1569563763","weight":5},{"id":"1569565087","weight":2},{"id":"1569566473","weight":6},{"id":"1569564857","weight":4},{"id":"1569566913","weight":3},{"id":"1569566809","weight":2},{"id":"1569566629","weight":3},{"id":"1569565033","weight":9},{"id":"1569566447","weight":4},{"id":"1569565817","weight":4},{"id":"1569565847","weight":6},{"id":"1569564353","weight":2},{"id":"1569563897","weight":2},{"id":"1569557083","weight":3},{"id":"1569565887","weight":2},{"id":"1569565929","weight":2},{"id":"1569566141","weight":5},{"id":"1569564677","weight":2},{"id":"1569563231","weight":2},{"id":"1569565633","weight":2},{"id":"1569565279","weight":2},{"id":"1569555879","weight":3},{"id":"1569566115","weight":2},{"id":"1569565219","weight":5},{"id":"1569558509","weight":2},{"id":"1569565595","weight":3},{"id":"1569565185","weight":3},{"id":"1569566773","weight":2},{"id":"1569566223","weight":2},{"id":"1569558401","weight":3},{"id":"1569566553","weight":3},{"id":"1569565469","weight":2},{"id":"1569564969","weight":4},{"id":"1569565029","weight":3},{"id":"1569565393","weight":2},{"id":"1569565933","weight":9},{"id":"1569562207","weight":3},{"id":"1569565705","weight":3},{"id":"1569566191","weight":3},{"id":"1569567033","weight":4},{"id":"1569565527","weight":4},{"id":"1569566603","weight":2},{"id":"1569567029","weight":2},{"id":"1569566159","weight":3},{"id":"1569566051","weight":2},{"id":"1569561379","weight":3},{"id":"1569561123","weight":7},{"id":"1569565467","weight":10},{"id":"1569566655","weight":2},{"id":"1569565739","weight":2},{"id":"1569565311","weight":2},{"id":"1569566233","weight":2},{"id":"1569566667","weight":2},{"id":"1569566893","weight":4},{"id":"1569566317","weight":2},{"id":"1569564097","weight":2},{"id":"1569560997","weight":2},{"id":"1569563845","weight":3},{"id":"1569566407","weight":2},{"id":"1569560349","weight":3},{"id":"1569566501","weight":4},{"id":"1569565741","weight":6},{"id":"1569566275","weight":4},{"id":"1569566481","weight":2},{"id":"1569565545","weight":2},{"id":"1569566857","weight":3},{"id":"1569565961","weight":2},{"id":"1569566245","weight":3},{"id":"1569560503","weight":6},{"id":"1569565463","weight":2},{"id":"1569564339","weight":2},{"id":"1569566219","weight":3},{"id":"1569565439","weight":3},{"id":"1569566229","weight":9},{"id":"1569566949","weight":6},{"id":"1569562551","weight":4},{"id":"1569566155","weight":5},{"id":"1569563395","weight":2},{"id":"1569566901","weight":2},{"id":"1569551347","weight":2},{"id":"1569565415","weight":3},{"id":"1569561623","weight":2},{"id":"1569566383","weight":2},{"id":"1569564485","weight":3},{"id":"1569565155","weight":3},{"id":"1569566631","weight":5},{"id":"1569565571","weight":4},{"id":"1569565885","weight":3},{"id":"1569566177","weight":5},{"id":"1569565493","weight":4},{"id":"1569557633","weight":3},{"id":"1569564411","weight":4},{"id":"1569566805","weight":4},{"id":"1569566293","weight":3},{"id":"1569565665","weight":2},{"id":"1569566831","weight":2},{"id":"1569565549","weight":2},{"id":"1569565523","weight":4},{"id":"1569557715","weight":4},{"id":"1569564175","weight":3},{"id":"1569566983","weight":2},{"id":"1569566097","weight":2},{"id":"1569566479","weight":3},{"id":"1569556361","weight":3},{"id":"1569565397","weight":3},{"id":"1569566873","weight":3},{"id":"1569565765","weight":56},{"id":"1569565925","weight":3},{"id":"1569565435","weight":2},{"id":"1569557275","weight":2},{"id":"1569565263","weight":4},{"id":"1569566129","weight":2},{"id":"1569565215","weight":2},{"id":"1569565385","weight":13},{"id":"1569565919","weight":4},{"id":"1569565181","weight":3},{"id":"1569566711","weight":5},{"id":"1569565241","weight":2},{"id":"1569566927","weight":3},{"id":"1569565661","weight":4},{"id":"1569565865","weight":3},{"id":"1569566887","weight":4},{"id":"1569565273","weight":2},{"id":"1569566267","weight":2},{"id":"1569564131","weight":4},{"id":"1569564919","weight":6},{"id":"1569565511","weight":2},{"id":"1569566737","weight":5},{"id":"1569566429","weight":2},{"id":"1569561221","weight":2},{"id":"1569564595","weight":12},{"id":"1569566917","weight":2},{"id":"1569565353","weight":2},{"id":"1569564683","weight":2},{"id":"1569564305","weight":4},{"id":"1569564283","weight":6},{"id":"1569564291","weight":7},{"id":"1569566691","weight":3},{"id":"1569565421","weight":3},{"id":"1569566547","weight":3},{"id":"1569566651","weight":2},{"id":"1569566823","weight":3},{"id":"1569566677","weight":2},{"id":"1569566137","weight":4},{"id":"1569565829","weight":2},{"id":"1569566283","weight":2},{"id":"1569565645","weight":2},{"id":"1569565375","weight":4},{"id":"1569565237","weight":3},{"id":"1569565041","weight":2},{"id":"1569564703","weight":2},{"id":"1569565541","weight":2},{"id":"1569566813","weight":3},{"id":"1569566771","weight":2},{"id":"1569564649","weight":5},{"id":"1569562277","weight":2},{"id":"1569566641","weight":2},{"id":"1569565425","weight":3},{"id":"1569564247","weight":2},{"id":"1569564437","weight":4},{"id":"1569566533","weight":2},{"id":"1569551905","weight":3},{"id":"1569564861","weight":3},{"id":"1569565457","weight":2},{"id":"1569566487","weight":2},{"id":"1569565529","weight":4},{"id":"1569556759","weight":3},{"id":"1569566619","weight":2},{"id":"1569561185","weight":2},{"id":"1569566397","weight":3},{"id":"1569558779","weight":2},{"id":"1569565233","weight":7},{"id":"1569565593","weight":2},{"id":"1569566817","weight":3},{"id":"1569564157","weight":4},{"id":"1569565729","weight":2},{"id":"1569564923","weight":3},{"id":"1569565367","weight":2},{"id":"1569566299","weight":5},{"id":"1569565039","weight":3},{"id":"1569564769","weight":2},{"id":"1569565769","weight":4},{"id":"1569565805","weight":3},{"id":"1569561713","weight":2},{"id":"1569563919","weight":3},{"id":"1569566577","weight":4},{"id":"1569557851","weight":3},{"id":"1569559919","weight":3},{"id":"1569565861","weight":3},{"id":"1569566147","weight":5},{"id":"1569565537","weight":2},{"id":"1569560785","weight":4},{"id":"1569565561","weight":3},{"id":"1569565631","weight":3},{"id":"1569560213","weight":3},{"id":"1569555891","weight":2},{"id":"1569565997","weight":2},{"id":"1569565035","weight":5},{"id":"1569564961","weight":2},{"id":"1569559251","weight":3},{"id":"1569566583","weight":2},{"id":"1569561861","weight":3},{"id":"1569565337","weight":3},{"id":"1569565737","weight":3},{"id":"1569560459","weight":2},{"id":"1569565853","weight":5},{"id":"1569550425","weight":3},{"id":"1569566273","weight":4},{"id":"1569564123","weight":5},{"id":"1569565889","weight":5},{"id":"1569566635","weight":3},{"id":"1569566611","weight":2},{"id":"1569551539","weight":2},{"id":"1569564505","weight":3},{"id":"1569565165","weight":2},{"id":"1569565565","weight":4},{"id":"1569565635","weight":2},{"id":"1569561397","weight":2},{"id":"1569565731","weight":4},{"id":"1569566797","weight":5},{"id":"1569566413","weight":4},{"id":"1569565707","weight":2},{"id":"1569565113","weight":3},{"id":"1569566375","weight":2},{"id":"1569565143","weight":4},{"id":"1569564257","weight":4},{"id":"1569565583","weight":3},{"id":"1569566555","weight":3},{"id":"1569564931","weight":3},{"id":"1569565373","weight":18},{"id":"1569566973","weight":4},{"id":"1569561579","weight":3},{"id":"1569566449","weight":2},{"id":"1569566987","weight":2},{"id":"1569565031","weight":3},{"id":"1569564755","weight":2},{"id":"1569551541","weight":2},{"id":"1569566839","weight":2},{"id":"1569551751","weight":3},{"id":"1569565139","weight":4},{"id":"1569566663","weight":3},{"id":"1569565579","weight":2},{"id":"1569566067","weight":3},{"id":"1569566825","weight":3},{"id":"1569566609","weight":2},{"id":"1569563007","weight":2},{"id":"1569566113","weight":4},{"id":"1569566443","weight":2},{"id":"1569566727","weight":5},{"id":"1569565315","weight":2},{"id":"1569560581","weight":4},{"id":"1569559233","weight":3}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S8.T5.1","endtime":"17:00","authors":"Nicolas Bitouzé, Alexandre Graell i Amat, Eirik Rosnes","date":"1341333600000","papertitle":"Making WOM Codes Decodable using Short Synchronous WOM Codes","starttime":"16:40","session":"S8.T5: WOM Codes","room":"Kresge Little Theatre (035)","paperid":"1569566075"},"cluster":{"jsonClass":"HashMap$HashTrieMap","spectral6":"4","spectral14":"9","spectral20":"1","spectral9":"4","spectral3":"1","spectral17":"5","louvain":"19","spectral10":"7","spectral15":"1","spectral5":"3","spectral8":"0","spectral11":"7","spectral4":"0","spectral12":"4","spectral19":"2","spectral7":"2","spectral13":"5","spectral18":"13","spectral2":"0","spectral16":"10"}}
